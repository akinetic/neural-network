<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" href="favicon.svg">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SLRM: Segmented Linear Regression Model</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- D3.js for graphic visualization -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #eef2ff; /* Very light blue */
        }
        .result-box {
            background-color: #f0f9ff;
            border-left: 4px solid #0ea5e9;
        }
        /* Styles for the SVG chart */
        .axis path, .axis line {
            fill: none;
            stroke: #d1d5db; /* Light gray */
            shape-rendering: crispEdges;
        }
        .segment-line {
            stroke-width: 3px;
            fill: none;
            stroke-linecap: round;
        }
        #chart-container {
            min-height: 450px; /* Increased for better visibility */
            background-color: #ffffff; 
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
        }
    </style>
</head>
<body class="p-4 md:p-8 min-h-screen">

    <div class="max-w-6xl mx-auto bg-white shadow-2xl rounded-xl p-6 md:p-10">
        <header class="mb-8 border-b pb-4">
            <h1 class="text-3xl font-extrabold text-indigo-700">SLRM: Segmented Linear Regression Model</h1>
            <p class="text-gray-500 mt-2">Demonstration of the neural compression algorithm (`neuron.py`).</p>
        </header>

        <!-- Chart Container -->
        <section class="mb-10 p-4 border border-indigo-200 rounded-lg bg-indigo-50">
            <h2 class="text-2xl font-semibold text-indigo-800 mb-4">Compressed Model Chart</h2>
            <div id="chart-container" class="w-full">
                <!-- D3.js chart will be drawn here -->
            </div>
            <p class="text-sm text-gray-500 mt-2 text-center">
                <span class="text-red-500 font-bold">● Original Data</span> | 
                <span class="text-emerald-600 font-bold">● Key Neurons</span> | 
                <span class="text-indigo-600 font-bold">― SLRM Line</span> | 
                <span class="text-yellow-600 font-bold">● Prediction</span>
            </p>
        </section>

        <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
            <!-- Prediction Section -->
            <section class="mb-6">
                <h2 class="text-2xl font-semibold text-gray-800 mb-4">1. Instant Prediction</h2>
                <p class="text-gray-600 mb-4">
                    Enter an X value (positive or **negative**) to get an instant prediction.
                </p>

                <div class="flex flex-col gap-4 mb-6">
                    <input type="text" id="inputX" placeholder="Enter an X value (e.g., -10, 0, 8)"
                           class="p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 shadow-sm transition duration-150">
                    <button onclick="getPrediction()"
                            class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-lg transition duration-300 shadow-md hover:shadow-lg">
                        Calculate Prediction
                    </button>
                </div>

                <!-- Prediction Result -->
                <div id="predictionResult" class="result-box p-4 rounded-lg hidden">
                    <p class="font-medium text-gray-700">Result:</p>
                    <p id="resultText" class="text-xl font-extrabold text-indigo-800 mt-1"></p>
                    <p id="resultSegment" class="text-sm text-gray-500 mt-2"></p>
                </div>
            </section>

            <!-- Structure Section -->
            <section>
                <h2 class="text-2xl font-semibold text-gray-800 mb-4">2. Compressed SLRM Structure</h2>
                <p class="text-gray-600 mb-4">
                    Final dictionary (`compressed_lossy_dict`) used for predictions.
                </p>

                <div class="bg-gray-50 border border-gray-200 rounded-lg p-4">
                    <p class="font-mono text-xs text-gray-600 mb-2">
                        // Key: X_start | Value: [Slope (Weight), Intercept (Bias)]
                    </p>
                    <pre id="displayDictionary" class="text-sm overflow-x-auto text-gray-700"></pre>
                </div>
            </section>
        </div>
        
        <!-- Main JavaScript Script -->
        <script>
            // --- DATA AND MODEL (JS Core) ---

            // Final, precise results from the neuron.py execution (Lossy Compression)
            const MRLS_DICT = {
                // X: [Slope (P), Intercept (O)]
                "-8": [-1.00, -12.00], // Segment [-8.0, -6.0]
                "-6": [0.00, -6.00],   // Segment [-6.0, -4.0] (Removes -5.0)
                "-4": [1.00, -2.00],   // Segment [-4.0, -2.0] 
                "-2": [2.00, 0.00],    // Segment [-2.0, +2.0] (Extends and removes X=0.0)
                "2": [3.00, -2.00],    // Segment [+2.0, +4.0] (Removes 3.0)
                "4": [4.00, -6.00],    // Segment [+4.0, +6.0]
                "6": [NaN, NaN]        // Final limit of the training range (X=+6.0)
            };
            
            // Original data points for the chart
            const ORIGINAL_DATA = [
                {x: -8.0, y: -4.0}, {x: -6.0, y: -6.0}, {x: -5.0, y: -6.01}, {x: -4.0, y: -6.0},
                {x: -2.0, y: -4.0}, {x: 0.0, y: 0.0}, {x: 2.0, y: 4.0}, {x: 3.0, y: 7.0},
                {x: 4.0, y: 10.0}, {x: 6.0, y: 18.0}
            ].map(d => ({ x: d.x, y: d.y }));


            /**
             * Function to format the dictionary in ascending numerical order.
             * Applies the '+' sign to positive keys.
             */
            function formatDictionary(dict) {
                // 1. Get keys as numbers and sort them
                const keys = Object.keys(dict).map(Number).sort((a, b) => a - b);
                
                let formattedText = "{\n";
                
                // 2. Iterate over the sorted keys to build the text
                keys.forEach(key => {
                    // Exclude the final limit point 6:NaN for dictionary visualization
                    if (key === 6 && isNaN(dict[key.toString()][0])) {
                        return; 
                    }
                    
                    const [P, O] = dict[key.toString()];
                    
                    // Format the key (X_start): adds '+' if positive
                    const keyStr = key >= 0 ? `+${key}` : key.toString();

                    // Format values, replacing NaN with 'null' and using 2 decimals
                    const pStr = isNaN(P) ? "null" : P.toFixed(2);
                    const oStr = isNaN(O) ? "null" : O.toFixed(2);
                    
                    formattedText += `  ${keyStr}: [ ${pStr}, ${oStr} ]\n`;
                });
                
                formattedText += "}";
                return formattedText;
            }

            // Displays the dictionary in readable, sorted format
            document.getElementById('displayDictionary').textContent = formatDictionary(MRLS_DICT);


            /**
             * JS implementation of the predict(x, dictionary) function
             * Internally uses the limit point X=6.0.
             */
            function predictMRLS(x) {
                // Get sorted keys of segment start points
                const keys = Object.keys(MRLS_DICT).map(Number).sort((a, b) => a - b);
                
                const minX = keys[0]; // -8.0
                // The key of the last valid segment (4.0)
                const maxXSegmentKey = keys[keys.length - 2]; 
                // The maximum training limit (6.0)
                const finalXLimit = keys[keys.length - 1];
                
                let targetX = null;
                let description = "Interpolation (within range)";
                
                // --- Generalization: Lower Extreme (X < minX) ---
                if (x < minX) {
                    targetX = minX;
                    description = `LOWER EXTRAPOLATION`;
                } else {
                    // 1. Search for the active segment (closest Xn less than or equal)
                    for (let i = keys.length - 1; i >= 0; i--) {
                        // Search for the key point that is less than or equal to X, and has valid parameters
                        if (x >= keys[i] && !isNaN(MRLS_DICT[keys[i].toString()][0])) {
                            targetX = keys[i];
                            break;
                        }
                    }

                    // --- Generalization: Upper Extreme (X > endpoint) ---
                    // If the found segment is the last valid one (4.0), and X exceeds the final limit (6.0)
                    if (targetX === maxXSegmentKey && x > finalXLimit) {
                        description = `UPPER EXTRAPOLATION`;
                    }
                }
                
                if (targetX !== null) {
                    const [P, O] = MRLS_DICT[targetX.toString()];
                    
                    // If for some reason the chosen point is the limit (6.0), force the previous segment (4.0)
                    if (isNaN(P) || isNaN(O)) {
                        targetX = maxXSegmentKey; 
                        const [P_new, O_new] = MRLS_DICT[targetX.toString()];
                        const yPredicted = x * P_new + O_new;
                        return {
                            prediction: yPredicted,
                            segment: `Segment: [X=${targetX.toFixed(2)}] with P=${P_new.toFixed(2)} and O=${O_new.toFixed(2)}`,
                            description: `UPPER EXTRAPOLATION (Forced)`
                        };
                    }

                    const yPredicted = x * P + O;

                    return {
                        prediction: yPredicted,
                        segment: `Segment: [X=${targetX.toFixed(2)}] with P=${P.toFixed(2)} and O=${O.toFixed(2)}`,
                        description: description
                    };
                }
                
                return {
                    prediction: null,
                    segment: "",
                    description: "Error: Segment not found."
                };
            }

            /**
             * Function to handle user input and display the prediction.
             */
            function getPrediction() {
                const inputElement = document.getElementById('inputX');
                const resultBox = document.getElementById('predictionResult');
                const resultText = document.getElementById('resultText');
                const resultSegment = document.getElementById('resultSegment');

                // Use parseFloat to handle text input
                const x = parseFloat(inputElement.value);

                if (isNaN(x)) {
                    resultText.textContent = "Error! Please enter a valid number.";
                    resultSegment.textContent = "";
                    resultBox.classList.remove('hidden');
                    d3.select('#prediction-point').remove();
                    return;
                }

                const result = predictMRLS(x);

                if (result.prediction !== null) {
                    resultText.innerHTML = `Y = ${result.prediction.toFixed(3)}`;
                    resultSegment.textContent = `${result.description}. ${result.segment}`;
                    
                    // Calls the chart function to draw the prediction point
                    drawPredictionPoint(x, result.prediction);

                } else {
                    resultText.textContent = result.description;
                    resultSegment.textContent = "";
                    d3.select('#prediction-point').remove();
                }
                
                resultBox.classList.remove('hidden');
            }

            // --- D3.js VISUALIZATION ---
            
            let svg, xScale, yScale;

            function setupChart() {
                const container = document.getElementById('chart-container');
                const containerWidth = container.clientWidth || 600; 
                
                const margin = {top: 20, right: 30, bottom: 40, left: 50};
                const width = containerWidth - margin.left - margin.right;
                // Fixed CSS container height (450) minus margins
                const height = 450 - margin.top - margin.bottom; 

                // 1. Clear the container
                d3.select(container).select("svg").remove();

                // 2. Create the SVG
                svg = d3.select(container)
                    .append("svg")
                    .attr("width", width + margin.left + margin.right)
                    .attr("height", height + margin.top + margin.bottom)
                    .append("g")
                    .attr("transform", `translate(${margin.left},${margin.top})`);
                
                // 3. Get the data range
                const allX = ORIGINAL_DATA.map(d => d.x);
                const allY = ORIGINAL_DATA.map(d => d.y);

                const minX = d3.min(allX);
                const maxX = d3.max(allX);
                const minY = d3.min(allY);
                const maxY = d3.max(allY);

                // Extended range to show extrapolation
                const xRange = [minX - 3, maxX + 3]; 
                
                // KEY FIX: Extend Y range so extrapolations are visible
                const yRange = [minY - 5, maxY + 20]; 

                // 4. Define Scales
                xScale = d3.scaleLinear()
                    .domain(xRange) 
                    .range([0, width]);

                yScale = d3.scaleLinear()
                    .domain(yRange)
                    .range([height, 0]);

                // 5. Draw Axes
                // X-axis (horizontal) - moved to y=0 value
                svg.append("g")
                    .attr("transform", `translate(0,${yScale(0)})`)
                    .call(d3.axisBottom(xScale).tickSizeOuter(0))
                    .attr("class", "axis");

                // Y-axis (vertical) - moved to x=0 value
                svg.append("g")
                    .attr("transform", `translate(${xScale(0)},0)`)
                    .call(d3.axisLeft(yScale).tickSizeOuter(0))
                    .attr("class", "axis");
                
                // 6. Configure colors
                const P_purple = "#8b5cf6"; // Purple for extrapolation
                const P_indigo = "#4f46e5"; // Indigo for interpolation

                const mrlsKeys = Object.keys(MRLS_DICT).map(Number).sort((a, b) => a - b);
                
                // 7. Draw Extrapolation (Lower and Upper)
                
                // --- Lower Extrapolation (left) ---
                const minXSegment = MRLS_DICT[mrlsKeys[0].toString()]; // Segment [-8.0]
                if (minXSegment && !isNaN(minXSegment[0])) {
                    const P = minXSegment[0];
                    const O = minXSegment[1];
                    const xStart = mrlsKeys[0]; // X=-8.0 (segment start point)
                    const yStart = xStart * P + O;
                    const xEnd = xRange[0]; // X=-11.0 (chart limit)
                    const yEnd = xEnd * P + O;

                    svg.append("line")
                        .attr("x1", xScale(xStart))
                        .attr("y1", yScale(yStart))
                        .attr("x2", xScale(xEnd))
                        .attr("y2", yScale(yEnd))
                        .attr("class", "segment-line")
                        .attr("stroke", P_purple) 
                        .attr("stroke-dasharray", "5,5")
                        .attr("opacity", 0.8);
                }

                // --- Upper Extrapolation (right) ---
                const maxXSegmentIndex = mrlsKeys.length - 2; // Index of the key for the last valid segment (4.0)
                // The extrapolation start point must be the end of the last valid segment (X=6.0)
                const xExtrapolStart = mrlsKeys[mrlsKeys.length - 1]; // X=6.0
                const maxXSegment = MRLS_DICT[mrlsKeys[maxXSegmentIndex].toString()]; // Segment [4.0]
                
                if (maxXSegment && !isNaN(maxXSegment[0])) {
                    const P = maxXSegment[0]; // Slope of segment [4.0, 6.0]
                    const O = maxXSegment[1]; // Intercept of segment [4.0, 6.0]
                    
                    // Calculate Y at X=6.0 (extrapolation start point)
                    const yStart = xExtrapolStart * P + O; 
                    const xEnd = xRange[1]; // X=9.0 (chart limit)
                    const yEnd = xEnd * P + O;

                    // Draw line from X=6.0 (end of segment) to X=9.0 (chart extreme)
                    svg.append("line")
                        .attr("x1", xScale(xExtrapolStart)) 
                        .attr("y1", yScale(yStart))
                        .attr("x2", xScale(xEnd))
                        .attr("y2", yScale(yEnd))
                        .attr("class", "segment-line")
                        .attr("stroke", P_purple) 
                        .attr("stroke-dasharray", "5,5")
                        .attr("opacity", 0.8);
                }


                // 8. Draw Segments (Interpolation - solid line)
                for (let i = 0; i < mrlsKeys.length - 1; i++) {
                    const xStart = mrlsKeys[i];
                    const xEnd = mrlsKeys[i+1];
                    const [P, O] = MRLS_DICT[xStart.toString()];

                    if (isNaN(P) || isNaN(O)) continue; 

                    const segmentPoints = [
                        {x: xStart, y: xStart * P + O},
                        {x: xEnd, y: xEnd * P + O}
                    ];

                    svg.append("line")
                        .attr("x1", xScale(segmentPoints[0].x))
                        .attr("y1", yScale(segmentPoints[0].y))
                        .attr("x2", xScale(segmentPoints[1].x))
                        .attr("y2", yScale(segmentPoints[1].y))
                        .attr("class", "segment-line")
                        .attr("stroke", P_indigo); 
                }

                // 9. Draw Original Points (Training Data)
                svg.selectAll(".original-point")
                    .data(ORIGINAL_DATA)
                    .enter()
                    .append("circle")
                    .attr("class", "original-point")
                    .attr("cx", d => xScale(d.x))
                    .attr("cy", d => yScale(d.y))
                    .attr("r", 4)
                    .attr("fill", "#ef4444") 
                    .attr("opacity", 0.8);

                // 10. Draw Compressed Neurons (SLRM key points)
                // Use only the keys that represent active segment starts (excluding the final limit 6:NaN)
                const compressedPoints = mrlsKeys
                    .filter(key => key !== 6) 
                    .map(x => ({x: x, y: predictMRLS(x).prediction}))
                    .filter(d => d.y !== null);

                svg.selectAll(".compressed-neuron")
                    .data(compressedPoints)
                    .enter()
                    .append("circle")
                    .attr("class", "compressed-neuron")
                    .attr("cx", d => xScale(d.x))
                    .attr("cy", d => yScale(d.y))
                    .attr("r", 5)
                    .attr("fill", "#10b981") 
                    .attr("stroke", "#065f46")
                    .attr("stroke-width", 1.5);
            }

            /**
             * Draws a dynamic prediction point.
             */
            function drawPredictionPoint(x, y) {
                // Removes the previous point if it exists
                d3.select('#prediction-point').remove();
                
                // Draws the new point
                svg.append("circle")
                    .attr("id", "prediction-point")
                    .attr("cx", xScale(x))
                    .attr("cy", yScale(y))
                    .attr("r", 7)
                    .attr("fill", "#facc15") 
                    .attr("stroke", "#374151") 
                    .attr("stroke-width", 2);
            }

            // Initialization and Responsiveness:
            setupChart();
            window.addEventListener('resize', setupChart); 
        </script>
    </div>
</body>
</html>

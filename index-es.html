<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <link rel="icon" href="favicon.svg">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MRLS: Modelo de Regresión Lineal Segmentada</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- D3.js para la visualización gráfica -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #eef2ff; /* Azul muy claro */
        }
        .result-box {
            background-color: #f0f9ff;
            border-left: 4px solid #0ea5e9;
        }
        /* Estilos para el gráfico SVG */
        .axis path, .axis line {
            fill: none;
            stroke: #d1d5db; /* Gris claro */
            shape-rendering: crispEdges;
        }
        .segment-line {
            stroke-width: 3px;
            fill: none;
            stroke-linecap: round;
        }
        #chart-container {
            min-height: 450px; /* Aumentado para mejor visibilidad */
            background-color: #ffffff; 
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
        }
    </style>
</head>
<body class="p-4 md:p-8 min-h-screen">

    <div class="max-w-6xl mx-auto bg-white shadow-2xl rounded-xl p-6 md:p-10">
        <header class="mb-8 border-b pb-4">
            <!-- Título CORREGIDO para incluir "Modelo de" -->
            <h1 class="text-3xl font-extrabold text-indigo-700">MRLS: Modelo de Regresión Lineal Segmentada</h1>
            <!-- Subtítulo con aclaración sobre el algoritmo de compresión -->
            <p class="text-gray-500 mt-2">Demostración del algoritmo de compresión neuronal (<span class="font-mono text-gray-700">mrls-logos.py</span>).</p>
        </header>

        <!-- Contenedor del Gráfico -->
        <section class="mb-10 p-4 border border-indigo-200 rounded-lg bg-indigo-50">
            <h2 class="text-2xl font-semibold text-indigo-800 mb-4">Gráfico del Modelo Comprimido</h2>
            <div id="chart-container" class="w-full">
                <!-- Aquí se dibujará el gráfico D3.js -->
            </div>
            <p class="text-sm text-gray-500 mt-2 text-center">
                <span class="text-red-500 font-bold">● Datos Originales</span> | 
                <span class="text-emerald-600 font-bold">● Neuronas Clave</span> | 
                <span class="text-indigo-600 font-bold">― Línea MRLS</span> | 
                <span class="text-yellow-600 font-bold">● Predicción</span>
            </p>
        </section>

        <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
            <!-- Sección de Predicción -->
            <section class="mb-6">
                <h2 class="text-2xl font-semibold text-gray-800 mb-4">1. Predicción con Botón</h2>
                <p class="text-gray-600 mb-4">
                    Ingresa un valor de X (positivo o <span class="font-bold">negativo</span>) y presiona el botón para calcular la predicción.
                </p>

                <div class="flex flex-col gap-4 mb-6">
                    <!-- Solo onclick, sin oninput -->
                    <input type="text" id="inputX" placeholder="Ingresa un valor de X (e.g., -10, 0, 8)"
                           class="p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 shadow-sm transition duration-150">
                    <button onclick="getPrediction()"
                            class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-lg transition duration-300 shadow-md hover:shadow-lg">
                        Calcular Predicción
                    </button>
                </div>

                <!-- Resultado de la Predicción -->
                <div id="predictionResult" class="result-box p-4 rounded-lg hidden">
                    <p class="font-medium text-gray-700">Resultado:</p>
                    <p id="resultText" class="text-xl font-extrabold text-indigo-800 mt-1"></p>
                    <p id="resultSegment" class="text-sm text-gray-500 mt-2"></p>
                </div>
            </section>

            <!-- Sección de Estructura -->
            <section>
                <h2 class="text-2xl font-semibold text-gray-800 mb-4">2. Estructura del MRLS Comprimido</h2>
                <p class="text-gray-600 mb-4">
                    Diccionario final (`compressed_lossy_dict`) usado para las predicciones.
                </p>

                <div class="bg-gray-50 border border-gray-200 rounded-lg p-4">
                    <p class="font-mono text-xs text-gray-600 mb-2">
                        // Clave: X_inicio | Valor: [Pendiente (Peso), Ordenada (Sesgo)]
                    </p>
                    <pre id="displayDictionary" class="text-sm overflow-x-auto text-gray-700"></pre>
                </div>
            </section>
        </div>
        
        <!-- Script principal de JavaScript -->
        <script>
            // --- DATOS Y MODELO (Cerebro JS) ---

            // Resultados finales precisos de la ejecución de mrls-logos.py (Compresión con Pérdida)
            const MRLS_DICT = {
                // X: [Pendiente (P), Ordenada (O)]
                "-8": [-1.00, -12.00], // Segmento [-8.0, -6.0]
                "-6": [0.00, -6.00],   // Segmento [-6.0, -4.0] (Elimina -5.0)
                "-4": [1.00, -2.00],   // Segmento [-4.0, -2.0] 
                "-2": [2.00, 0.00],    // Segmento [-2.0, +2.0] (Extiende y elimina X=0.0)
                "2": [3.00, -2.00],    // Segmento [+2.0, +4.0] (Elimina 3.0)
                "4": [4.00, -6.00],    // Segmento [+4.0, +6.0]
                "6": [NaN, NaN]        // Límite final del rango de entrenamiento (X=+6.0)
            };
            
            // Puntos originales para la gráfica
            const ORIGINAL_DATA = [
                {x: -8.0, y: -4.0}, {x: -6.0, y: -6.0}, {x: -5.0, y: -6.01}, {x: -4.0, y: -6.0},
                {x: -2.0, y: -4.0}, {x: 0.0, y: 0.0}, {x: 2.0, y: 4.0}, {x: 3.0, y: 7.0},
                {x: 4.0, y: 10.0}, {x: 6.0, y: 18.0}
            ].map(d => ({ x: d.x, y: d.y }));


            /**
             * Función para formatear el diccionario en orden numérico ascendente.
             * Aplica el signo '+' a las claves positivas.
             */
            function formatDictionary(dict) {
                // 1. Obtener claves como números y ordenarlas
                const keys = Object.keys(dict).map(Number).sort((a, b) => a - b);
                
                let formattedText = "{\n";
                
                // 2. Iterar sobre las claves ordenadas para construir el texto
                keys.forEach(key => {
                    // Excluir el punto límite final 6:NaN para la visualización del diccionario
                    if (key === 6 && isNaN(dict[key.toString()][0])) {
                        return; 
                    }
                    
                    const [P, O] = dict[key.toString()];
                    
                    // Formatea la clave (X_inicio): añade '+' si es positivo
                    const keyStr = key >= 0 ? `+${key}` : key.toString();

                    // Formatea los valores, reemplazando NaN con 'null' y usando 2 decimales
                    const pStr = isNaN(P) ? "null" : P.toFixed(2);
                    const oStr = isNaN(O) ? "null" : O.toFixed(2);
                    
                    formattedText += `  ${keyStr}: [ ${pStr}, ${oStr} ]\n`;
                });
                
                formattedText += "}";
                return formattedText;
            }

            // Muestra el diccionario en formato legible y ordenado
            document.getElementById('displayDictionary').textContent = formatDictionary(MRLS_DICT);


            /**
             * Implementación en JS de la función predict(x, dictionary)
             * Utiliza el punto límite X=6.0 internamente.
             */
            function predictMRLS(x) {
                // Obtener claves ordenadas de los puntos de inicio de segmento
                const keys = Object.keys(MRLS_DICT).map(Number).sort((a, b) => a - b);
                
                const minX = keys[0]; // -8.0
                // La clave del último segmento válido (4.0)
                const maxXSegmentKey = keys[keys.length - 2]; 
                // El límite máximo de entrenamiento (6.0)
                const finalXLimit = keys[keys.length - 1];
                
                let targetX = null;
                let description = "Interpolación (dentro del rango)";
                
                // --- Generalización: Extremo Menor (X < minX) ---
                if (x < minX) {
                    targetX = minX;
                    description = `EXTRAPOLACIÓN Menor`;
                } else {
                    // 1. Búsqueda del segmento activo (Xn más próximo menor o igual)
                    for (let i = keys.length - 1; i >= 0; i--) {
                        // Buscar el punto clave que es menor o igual a X, y que tiene parámetros válidos
                        if (x >= keys[i] && !isNaN(MRLS_DICT[keys[i].toString()][0])) {
                            targetX = keys[i];
                            break;
                        }
                    }

                    // --- Generalización: Extremo Mayor (X > punto final) ---
                    // Si el segmento encontrado es el último válido (4.0), y X supera el límite final (6.0)
                    if (targetX === maxXSegmentKey && x > finalXLimit) {
                        description = `EXTRAPOLACIÓN Mayor`;
                    }
                }
                
                if (targetX !== null) {
                    const [P, O] = MRLS_DICT[targetX.toString()];
                    
                    // Si por alguna razón el punto elegido es el límite (6.0), forzamos al segmento anterior (4.0)
                    if (isNaN(P) || isNaN(O)) {
                        targetX = maxXSegmentKey; 
                        const [P_new, O_new] = MRLS_DICT[targetX.toString()];
                        const yPredicted = x * P_new + O_new;
                        return {
                            prediction: yPredicted,
                            segment: `Segmento: [X=${targetX.toFixed(2)}] con P=${P_new.toFixed(2)} y O=${O_new.toFixed(2)}`,
                            description: `EXTRAPOLACIÓN Mayor (Forzado)`
                        };
                    }

                    const yPredicted = x * P + O;

                    return {
                        prediction: yPredicted,
                        segment: `Segmento: [X=${targetX.toFixed(2)}] con P=${P.toFixed(2)} y O=${O.toFixed(2)}`,
                        description: description
                    };
                }
                
                return {
                    prediction: null,
                    segment: "",
                    description: "Error: No se encontró segmento."
                };
            }

            /**
             * Función para manejar la entrada del usuario y mostrar la predicción (activada por el botón).
             */
            function getPrediction() {
                const inputElement = document.getElementById('inputX');
                const resultBox = document.getElementById('predictionResult');
                const resultText = document.getElementById('resultText');
                const resultSegment = document.getElementById('resultSegment');

                // Usar parseFloat para manejar el input de tipo texto
                const x = parseFloat(inputElement.value);

                if (isNaN(x)) {
                    // Si el input está vacío o no es un número, muestra un error.
                    resultText.textContent = "¡Error! Por favor, ingresa un número válido.";
                    resultSegment.textContent = "";
                    resultBox.classList.remove('hidden');
                    // Remueve el punto de predicción si no hay un valor válido
                    d3.select('#prediction-point').remove();
                    return;
                }

                const result = predictMRLS(x);

                if (result.prediction !== null) {
                    resultText.innerHTML = `Y = ${result.prediction.toFixed(3)}`;
                    resultSegment.textContent = `${result.description}. ${result.segment}`;
                    
                    // Llama a la función de gráfico para dibujar el punto de predicción
                    drawPredictionPoint(x, result.prediction);

                } else {
                    resultText.textContent = result.description;
                    resultSegment.textContent = "";
                    d3.select('#prediction-point').remove();
                }
                
                resultBox.classList.remove('hidden');
            }

            // --- VISUALIZACIÓN D3.js ---
            
            let svg, xScale, yScale;

            function setupChart() {
                const container = document.getElementById('chart-container');
                const containerWidth = container.clientWidth || 600; 
                
                const margin = {top: 20, right: 30, bottom: 40, left: 50};
                const width = containerWidth - margin.left - margin.right;
                // Altura fija del contenedor CSS (450) menos los márgenes
                const height = 450 - margin.top - margin.bottom; 

                // 1. Limpia el contenedor
                d3.select(container).select("svg").remove();

                // 2. Crea el SVG
                svg = d3.select(container)
                    .append("svg")
                    .attr("width", width + margin.left + margin.right)
                    .attr("height", height + margin.top + margin.bottom)
                    .append("g")
                    .attr("transform", `translate(${margin.left},${margin.top})`);
                
                // 3. Obtiene el rango de datos
                const allX = ORIGINAL_DATA.map(d => d.x);
                const allY = ORIGINAL_DATA.map(d => d.y);

                const minX = d3.min(allX);
                const maxX = d3.max(allX);
                const minY = d3.min(allY);
                const maxY = d3.max(allY);

                // Rango extendido para mostrar la extrapolación
                const xRange = [minX - 3, maxX + 3]; 
                
                // Ampliamos el rango Y para que las extrapolaciones sean visibles
                const yRange = [minY - 5, maxY + 20]; 

                // 4. Define las Escalas
                xScale = d3.scaleLinear()
                    .domain(xRange) 
                    .range([0, width]);

                yScale = d3.scaleLinear()
                    .domain(yRange)
                    .range([height, 0]);

                // 5. Dibuja los Ejes
                // Eje X (horizontal) - movido al valor y=0
                svg.append("g")
                    .attr("transform", `translate(0,${yScale(0)})`)
                    .call(d3.axisBottom(xScale).tickSizeOuter(0))
                    .attr("class", "axis");

                // Eje Y (vertical) - movido al valor x=0
                svg.append("g")
                    .attr("transform", `translate(${xScale(0)},0)`)
                    .call(d3.axisLeft(yScale).tickSizeOuter(0))
                    .attr("class", "axis");
                
                // 6. Configura colores
                const P_purple = "#8b5cf6"; // Púrpura para extrapolación
                const P_indigo = "#4f46e5"; // Indigo para interpolación

                const mrlsKeys = Object.keys(MRLS_DICT).map(Number).sort((a, b) => a - b);
                
                // 7. Dibuja la Extrapolación (Menor y Mayor)
                
                // --- Extrapolación Menor (izquierda) ---
                const minXSegment = MRLS_DICT[mrlsKeys[0].toString()]; // Segmento [-8.0]
                if (minXSegment && !isNaN(minXSegment[0])) {
                    const P = minXSegment[0];
                    const O = minXSegment[1];
                    const xStart = mrlsKeys[0]; // X=-8.0 (punto de inicio del segmento)
                    const yStart = xStart * P + O;
                    const xEnd = xRange[0]; // X=-11.0 (límite del gráfico)
                    const yEnd = xEnd * P + O;

                    svg.append("line")
                        .attr("x1", xScale(xStart))
                        .attr("y1", yScale(yStart))
                        .attr("x2", xScale(xEnd))
                        .attr("y2", yScale(yEnd))
                        .attr("class", "segment-line")
                        .attr("stroke", P_purple) 
                        .attr("stroke-dasharray", "5,5")
                        .attr("opacity", 0.8);
                }

                // --- Extrapolación Mayor (derecha) ---
                const maxXSegmentIndex = mrlsKeys.length - 2; // Índice de la clave del último segmento válido (4.0)
                // El punto de inicio de la extrapolación debe ser el final del último segmento válido (X=6.0)
                const xExtrapolStart = mrlsKeys[mrlsKeys.length - 1]; // X=6.0
                const maxXSegment = MRLS_DICT[mrlsKeys[maxXSegmentIndex].toString()]; // Segmento [4.0]
                
                if (maxXSegment && !isNaN(maxXSegment[0])) {
                    const P = maxXSegment[0]; // Pendiente del segmento [4.0, 6.0]
                    const O = maxXSegment[1]; // Ordenada del segmento [4.0, 6.0]
                    
                    // Calculamos Y en X=6.0 (punto de inicio de la extrapolación)
                    const yStart = xExtrapolStart * P + O; 
                    const xEnd = xRange[1]; // X=9.0 (límite del gráfico)
                    const yEnd = xEnd * P + O;

                    // Dibujar línea desde X=6.0 (final del segmento) hasta X=9.0 (extremo del gráfico)
                    svg.append("line")
                        .attr("x1", xScale(xExtrapolStart)) 
                        .attr("y1", yScale(yStart))
                        .attr("x2", xScale(xEnd))
                        .attr("y2", yScale(yEnd))
                        .attr("class", "segment-line")
                        .attr("stroke", P_purple) 
                        .attr("stroke-dasharray", "5,5")
                        .attr("opacity", 0.8);
                }


                // 8. Dibuja los Segmentos (Interpolación - línea sólida)
                for (let i = 0; i < mrlsKeys.length - 1; i++) {
                    const xStart = mrlsKeys[i];
                    const xEnd = mrlsKeys[i+1];
                    const [P, O] = MRLS_DICT[xStart.toString()];

                    if (isNaN(P) || isNaN(O)) continue; 

                    const segmentPoints = [
                        {x: xStart, y: xStart * P + O},
                        {x: xEnd, y: xEnd * P + O}
                    ];

                    svg.append("line")
                        .attr("x1", xScale(segmentPoints[0].x))
                        .attr("y1", yScale(segmentPoints[0].y))
                        .attr("x2", xScale(segmentPoints[1].x))
                        .attr("y2", yScale(segmentPoints[1].y))
                        .attr("class", "segment-line")
                        .attr("stroke", P_indigo); 
                }

                // 9. Dibuja los Puntos Originales (Datos de entrenamiento)
                svg.selectAll(".original-point")
                    .data(ORIGINAL_DATA)
                    .enter()
                    .append("circle")
                    .attr("class", "original-point")
                    .attr("cx", d => xScale(d.x))
                    .attr("cy", d => yScale(d.y))
                    .attr("r", 4)
                    .attr("fill", "#ef4444") 
                    .attr("opacity", 0.8);

                // 10. Dibuja las Neuronas Comprimidas (puntos clave del MRLS)
                // Usamos solo las claves que representan inicios de segmento activos (excluyendo el límite final 6:NaN)
                const compressedPoints = mrlsKeys
                    .filter(key => key !== 6) 
                    .map(x => ({x: x, y: predictMRLS(x).prediction}))
                    .filter(d => d.y !== null);

                svg.selectAll(".compressed-neuron")
                    .data(compressedPoints)
                    .enter()
                    .append("circle")
                    .attr("class", "compressed-neuron")
                    .attr("cx", d => xScale(d.x))
                    .attr("cy", d => yScale(d.y))
                    .attr("r", 5)
                    .attr("fill", "#10b981") 
                    .attr("stroke", "#065f46")
                    .attr("stroke-width", 1.5);
                
                // Inicialmente, no hay predicción visible.
                // getPrediction(); // Desactivado para que el usuario use el botón.
            }

            /**
             * Dibuja un punto de predicción dinámico.
             * CORRECCIÓN: Se añade una verificación para asegurar que el objeto SVG esté inicializado.
             */
            function drawPredictionPoint(x, y) {
                // Verificar que las variables D3 (svg, xScale, yScale) estén definidas
                if (!svg || !xScale || !yScale) {
                    console.warn("D3 no está completamente inicializado. Inténtalo de nuevo.");
                    // Si no está listo, simplemente salimos sin intentar dibujar.
                    return; 
                }

                // Elimina el punto anterior si existe
                d3.select('#prediction-point').remove();
                
                // Dibuja el nuevo punto
                svg.append("circle")
                    .attr("id", "prediction-point")
                    .attr("cx", xScale(x))
                    .attr("cy", yScale(y))
                    .attr("r", 7)
                    .attr("fill", "#facc15") 
                    .attr("stroke", "#374151") 
                    .attr("stroke-width", 2);
            }

            // Inicialización y Responsividad:
            setupChart();
            window.addEventListener('resize', setupChart); 
        </script>
    </div>
</body>
</html>

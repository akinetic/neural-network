<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- CHANGE: Version number updated to V5.8 -->
    <title>SLRM-Logos Interactive Visualizer (V5.8)</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- D3.js CDN for Visualization -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; }
        
        /* New styles for the data points */
        .eliminated-point { fill: #ef4444; stroke: #b91c1c; stroke-width: 1.5px; } /* Rojo: Puntos eliminados/intermedios */
        .breakpoint-point { fill: #3b82f6; stroke: #1e3a8a; stroke-width: 1.5px; } /* Azul: Puntos mantenidos/quiebres */

        .model-segment { stroke: #10b981; stroke-width: 3px; fill: none; }
        .breakpoint { fill: #1e3a8a; stroke: #1e3a8a; stroke-width: 2px; } /* Marcadores de quiebre (pequeños círculos) */
        .prediction-line { stroke: #3b82f6; stroke-dasharray: 5, 5; stroke-width: 2px; }
        
        /* Style for custom alert/message box */
        .message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 15px 30px;
            background-color: #fefcbf; /* Yellow warning background */
            border: 2px solid #facc15;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            max-width: 90%;
            text-align: center;
            opacity: 1;
            transition: opacity 0.5s ease;
        }
        .message-box.hidden {
            display: none;
            opacity: 0;
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen p-4 sm:p-8">

    <div class="max-w-7xl mx-auto">
        <header class="text-center mb-8">
            <!-- CHANGE: Version number updated to V5.8 -->
            <h1 class="text-4xl font-bold text-gray-800">SLRM-Logos Interactive Visualizer <span class="text-sm font-light text-gray-500">(V5.8)</span></h1>
            <p class="text-gray-600 mt-2">Segmented Linear Regression Model (MRLS Algorithm with Geometric Invariance)</p>
        </header>

        <!-- Configuration and Metrics -->
        <div class="grid grid-cols-1 lg:col-cols-3 gap-6 mb-8">
            <!-- Data Input -->
            <div class="col-span-1 lg:col-span-1 bg-white p-6 rounded-xl shadow-lg border border-gray-200">
                <h2 class="text-xl font-semibold mb-3 text-gray-700">1. Input Data (X, Y)</h2>
                <textarea id="inputData" rows="10" class="w-full p-3 border border-gray-300 rounded-lg text-sm font-mono focus:ring-blue-500 focus:border-blue-500" placeholder="Enter data points (X, Y) separated by comma or space, one per line.">
1, 1
2, 1.5
3, 1.7
4, 3.5
5, 5
6, 4.8
7, 4.5
8, 4.3
9, 4.1
10, 4.2
11, 4.3
12, 4.6
13, 5.5
14, 7
15, 8.5
</textarea>
                <p class="text-xs text-gray-500 mt-1">Example: <code>X, Y</code> or <code>X Y</code></p>
            </div>

            <!-- Controls and Parameters -->
            <div class="col-span-1 lg:col-span-1 bg-white p-6 rounded-xl shadow-lg border border-gray-200">
                <h2 class="text-xl font-semibold mb-3 text-gray-700">2. Configuration</h2>
                <div class="mb-4">
                    <label for="epsilon" class="block text-sm font-medium text-gray-700 mb-1">Error Tolerance (Epsilon, &epsilon;)</label>
                    <!-- Default value remains 0.50 -->
                    <input type="number" id="epsilon" value="0.50" step="0.000001" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500">
                    <p class="text-xs text-gray-500 mt-1">Si &epsilon; = 0, se aplica solo Invarianza Geométrica.</p>
                </div>
                
                <button id="trainButton" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-[1.01] focus:outline-none focus:ring-4 focus:ring-blue-500/50">
                    <svg id="loadingSpinner" class="animate-spin -ml-1 mr-3 h-5 w-5 text-white hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                    Train SLRM Model
                </button>
            </div>

            <!-- Metrics -->
            <div class="col-span-1 lg:col-span-1 bg-white p-6 rounded-xl shadow-lg border border-gray-200">
                <h2 class="text-xl font-semibold mb-3 text-gray-700">3. Model Metrics</h2>
                <div class="space-y-3 text-gray-700">
                    <p class="flex justify-between">
                        <span class="font-medium">Original Points:</span>
                        <span id="metricPoints" class="font-bold text-gray-800">0</span>
                    </p>
                    <p class="flex justify-between">
                        <span class="font-medium">Segments (Breakpoints):</span>
                        <span id="metricSegments" class="font-bold text-green-600">0</span>
                    </p>
                    <p class="flex justify-between">
                        <span class="font-medium">Compression Ratio:</span>
                        <span id="metricRatio" class="font-bold text-blue-600">0.00%</span>
                    </p>
                    <p class="flex justify-between">
                        <span class="font-medium">Max Error Achieved:</span>
                        <span id="metricMaxError" class="font-bold text-red-600">N/A</span>
                    </p>
                </div>
                <div id="predictionBox" class="mt-4 p-3 bg-indigo-50 border border-indigo-200 rounded-lg hidden">
                    <p class="text-sm font-semibold text-indigo-800">Click Prediction (X= <span id="predX"></span>)</p>
                    <p class="text-lg font-bold text-indigo-900">Ŷ = <span id="predY"></span></p>
                </div>
            </div>
        </div>

        <!-- Visualization Area -->
        <div class="bg-white p-4 sm:p-6 rounded-xl shadow-xl border border-gray-200">
            <h2 class="text-xl font-semibold mb-4 text-gray-700">4. Model Visualization (Click on chart for Prediction)</h2>
            <div id="chartContainer" class="w-full h-[500px] overflow-hidden">
                <svg id="slrmChart" class="w-full h-full"></svg>
            </div>
        </div>
    </div>

    <!-- Custom Message Box for errors/warnings -->
    <div id="customMessageBox" class="message-box hidden">
        <p id="messageText" class="text-lg font-semibold text-gray-900 mb-0"></p>
    </div>

    <script>
        // --- UTILITY FUNCTIONS ---
        
        /**
         * Shows a persistent error message (requires user click to close).
         */
        function showPersistentMessage(text) {
            const msgBox = document.getElementById('customMessageBox');
            document.getElementById('messageText').textContent = text;
            msgBox.classList.remove('hidden');
            // Change background for error
            msgBox.style.backgroundColor = '#fee2e2'; 
            msgBox.style.borderColor = '#ef4444';
            // Add a close button for persistent messages
            let closeBtn = msgBox.querySelector('button');
            if (!closeBtn) {
                closeBtn = document.createElement('button');
                closeBtn.textContent = 'Cerrar';
                closeBtn.onclick = () => msgBox.classList.add('hidden');
                closeBtn.className = 'bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg mt-3';
                msgBox.appendChild(closeBtn);
            }
        }
        
        /**
         * Shows a temporary warning message that disappears after 3 seconds.
         */
        function showTimedMessage(text) {
            const msgBox = document.getElementById('customMessageBox');
            document.getElementById('messageText').textContent = text;
            msgBox.classList.remove('hidden');
            
            // Remove close button if present
            let closeBtn = msgBox.querySelector('button');
            if (closeBtn) {
                msgBox.removeChild(closeBtn);
            }

            // Restore warning styles
            msgBox.style.backgroundColor = '#fefcbf';
            msgBox.style.borderColor = '#facc15';

            // Automatically hide after 3 seconds
            setTimeout(() => {
                msgBox.classList.add('hidden');
            }, 3000); 
        }

        // Utility function to yield control back to the UI thread (prevents freezing)
        const yieldControl = () => new Promise(resolve => setTimeout(resolve, 0));

        // --- SLRM CORE LOGIC (V5.8) ---

        /** Global variable to store original points for boundary checks */
        let originalPoints = []; 

        /**
         * Cleans and sorts input data, handling duplicate X values by averaging Y.
         */
        function _cleanAndSortData(dataString) {
            const pointsMap = new Map();
            const rawLines = dataString.split('\n');
            
            rawLines.forEach(line => {
                const parts = line.trim().split(/[\s,]+/).map(p => parseFloat(p.trim()));
                if (parts.length >= 2 && !isNaN(parts[0]) && !isNaN(parts[1])) {
                    const x = parts[0];
                    const y = parts[1];
                    
                    if (pointsMap.has(x)) {
                        const current = pointsMap.get(x);
                        current.y = (current.y * current.count + y) / (current.count + 1);
                        current.count += 1;
                    } else {
                        pointsMap.set(x, { x: x, y: y, count: 1 });
                    }
                }
            });

            const cleanedData = Array.from(pointsMap.values()).map(p => ({x: p.x, y: p.y}));
            cleanedData.sort((a, b) => a.x - b.x);

            return cleanedData;
        }

        /**
         * Removes geometrically collinear breakpoints (Lossless Compression - Geometric Invariance).
         * Returns an array of critical X-breakpoints (subset of original X-values).
         */
        function _losslessCompression(data) {
            if (data.length < 3) return data.map(d => d.x);

            const criticalX = [data[0].x]; // The first point is always a critical breakpoint (X_start)
            
            for (let i = 1; i < data.length - 1; i++) {
                const p0 = data[i - 1]; // Previous point
                const p1 = data[i];     // Point being tested for redundancy (X_mid)
                const p2 = data[i + 1]; // Next point

                const dX_a = p1.x - p0.x;
                const dX_b = p2.x - p1.x;
                
                if (dX_a === 0 || dX_b === 0) continue; 

                const P_a = (p1.y - p0.y) / dX_a; 
                const P_b = (p2.y - p1.y) / dX_b; 

                // Check for collinearity (Geometric Invariance). Use tolerance 1e-9.
                if (Math.abs(P_a - P_b) > 1e-9) {
                    criticalX.push(p1.x);
                }
            }

            // The last point is always a critical point (end of data)
            criticalX.push(data[data.length - 1].x);

            return Array.from(new Set(criticalX));
        }

        /**
         * Implements the Minimum Required Line Segments (MRLS) algorithm (Lossy Compression).
         */
        async function _lossyCompression(initialKeys, epsilon, data) {
            const dataKeys = data.map(d => d.x);
            const dataMap = new Map(data.map(p => [p.x, p.y]));
            
            if (initialKeys.length < 2) {
                return { finalModel: new Map(), maxError: 0 };
            }

            // Use epsilon directly. If epsilon is 0, the safeEpsilon for comparison will be 1e-12 
            // to prevent issues with strict floating point arithmetic inside the loop, 
            // ensuring only perfect collinearity passes if epsilon is 0.
            const safeEpsilon = Math.max(epsilon, 1e-12); 

            const finalModel = new Map();
            let i = 0; // Index of the starting breakpoint in initialKeys
            let maxOverallError = 0;

            // MRLS Loop
            while (i < initialKeys.length - 1) {
                
                const x_start = initialKeys[i];
                const y_start = dataMap.get(x_start);
                
                let j = i + 1; // Index of the candidate ending breakpoint (x_end_candidate)

                while (j < initialKeys.length) {
                    
                    if ((j - (i + 1)) % 5 === 0) { 
                        await yieldControl();
                    }

                    const x_end_candidate = initialKeys[j];
                    const y_end_candidate = dataMap.get(x_end_candidate);

                    const dX = x_end_candidate - x_start;
                    if (dX === 0) { j++; continue; } 

                    const P_test = (y_end_candidate - y_start) / dX;
                    const O_test = y_start - P_test * x_start;

                    let currentMaxError = 0; 
                    let errorExceeded = false;
                    
                    const startIndex = dataKeys.indexOf(x_start);
                    const endIndex = dataKeys.indexOf(x_end_candidate);

                    for (let k = startIndex + 1; k < endIndex; k++) {
                        const x_mid = data[k].x;
                        const y_true_mid = data[k].y;
                        
                        const y_hat_mid = P_test * x_mid + O_test;
                        const error = Math.abs(y_true_mid - y_hat_mid);

                        currentMaxError = Math.max(currentMaxError, error);

                        // Use the user-defined epsilon for the threshold check, 
                        // falling back to a tiny number if epsilon is 0 to enforce precision.
                        if (error > epsilon && error > 1e-12) { 
                            errorExceeded = true;
                            break; 
                        }
                    }
                    
                    if (errorExceeded) {
                        // Segment failed at index j. Commit the previous valid segment (i -> j-1).
                        const x_end_committed = initialKeys[j - 1];
                        const y_end_committed = dataMap.get(x_end_committed);
                        
                        // Recalculate P and O for the COMMITTED segment
                        const dX_committed = x_end_committed - x_start;
                        const P = dX_committed === 0 ? 0 : (y_end_committed - y_start) / dX_committed;
                        const O = y_start - P * x_start;
                        
                        finalModel.set(x_start, [P, O, x_end_committed]);
                        
                        // Calculate the actual max error of the segment committed
                        let committedMaxError = 0;
                        const committedStartIndex = dataKeys.indexOf(x_start);
                        const committedEndIndex = dataKeys.indexOf(x_end_committed);
                        for (let k = committedStartIndex + 1; k < committedEndIndex; k++) {
                            const x_mid = data[k].x;
                            const y_true_mid = data[k].y;
                            const y_hat_mid = P * x_mid + O;
                            committedMaxError = Math.max(committedMaxError, Math.abs(y_true_mid - y_hat_mid));
                        }
                        
                        maxOverallError = Math.max(maxOverallError, committedMaxError);

                        i = j - 1; // Next segment starts at j-1
                        break; 
                        
                    } else if (j === initialKeys.length - 1) {
                        // Reached the very last point, this is the final segment (i -> j) and it passed.
                        const x_end = initialKeys[j];
                        const y_end = dataMap.get(x_end);
                        
                        const dX = x_end - x_start;
                        const P = dX === 0 ? 0 : (y_end - y_start) / dX; 
                        const O = y_start - P * x_start;
                        
                        finalModel.set(x_start, [P, O, x_end]);
                        maxOverallError = Math.max(maxOverallError, currentMaxError);
                        
                        i = j; // Loop terminates
                        break;
                    }
                    
                    j++; // Try to extend the segment further
                }
            }

            // Re-add the final NaN marker if the loop terminated without adding the last point as a key
            const lastKey = initialKeys[initialKeys.length - 1];
            if (lastKey !== undefined && !finalModel.has(lastKey)) {
                 finalModel.set(lastKey, [NaN, NaN, NaN]);
            }

            return { finalModel, maxError: maxOverallError };
        }


        /**
         * Main training function (slrm-logos.py:train_slrm).
         */
        async function train_slrm(dataString, epsilon) {
            originalPoints = _cleanAndSortData(dataString);
            if (originalPoints.length < 2) return { model: new Map(), originalData: originalPoints, maxError: 0 };
            
            // 1. Lossless Compression (Geometric Invariance)
            const initialBreakpoints = _losslessCompression(originalPoints);
            
            // 2. Lossy Compression (MRLS)
            await yieldControl();
            const result = await _lossyCompression(initialBreakpoints, epsilon, originalPoints);

            return { model: result.finalModel, originalData: originalPoints, maxError: result.maxError };
        }

        /**
         * Main prediction function (slrm-logos.py:predict_slrm).
         */
        function predict_slrm(x_in, model) {
            const keys = Array.from(model.entries())
                .filter(([x_start, [P]]) => !isNaN(P))
                .map(([x_start]) => x_start); 
            keys.sort((a, b) => a - b); 

            if (keys.length === 0 || originalPoints.length === 0) {
                return { x_in, y_pred: NaN, slope_P: NaN, intercept_O: NaN };
            }

            const dataMinX = originalPoints[0].x;
            const dataMaxX = originalPoints[originalPoints.length - 1].x;
            
            let activeKey = null;

            if (x_in < dataMinX) {
                // Extrapolation to the left: use the first segment
                activeKey = keys[0];
            } else if (x_in >= dataMaxX) {
                // Extrapolation to the right: use the last segment
                activeKey = keys[keys.length - 1]; 
            } else {
                // Interpolation: find the segment where x_start <= x_in < x_end
                for (let i = 0; i < keys.length; i++) {
                    const x_start = keys[i];
                    const x_end = model.get(x_start)[2]; // Get x_end from the model
                    
                    // We check x_in >= x_start AND x_in is less than the segment's end. 
                    if (x_in >= x_start && x_in < x_end) { 
                        activeKey = x_start;
                        break;
                    }
                }
                
                // Fallback for the very last data point if the loop above missed it
                if (activeKey === null) {
                    for (let i = 0; i < keys.length; i++) {
                        if (keys[i] <= x_in) {
                            activeKey = keys[i];
                        } else {
                            break;
                        }
                    }
                }
            }

            const [P, O] = model.get(activeKey) || [NaN, NaN];
            
            let y_pred = NaN;
            if (!isNaN(P) && !isNaN(O)) {
                y_pred = x_in * P + O;
            }

            return {
                x_in,
                y_pred,
                slope_P: P,
                intercept_O: O
            };
        }


        // --- D3 VISUALIZATION AND INTERACTIVITY ---

        const svg = d3.select("#slrmChart");
        const margin = { top: 20, right: 30, bottom: 40, left: 50 };
        let width, height;
        let xScale, yScale;
        let trainedModel = null;

        function updateDimensions() {
            width = svg.node().clientWidth - margin.left - margin.right;
            height = svg.node().clientHeight - margin.top - margin.bottom;
        }

        /**
         * Renders the chart using D3.js.
         */
        function renderChart() {
            updateDimensions();
            svg.selectAll("*").remove(); // Clear previous chart content

            if (originalPoints.length === 0) return;

            // 1. Define Scales
            const xExtent = d3.extent(originalPoints, d => d.x);
            const yExtent = d3.extent(originalPoints, d => d.y);

            const xRange = xExtent[1] - xExtent[0];
            const yRange = yExtent[1] - yExtent[0];

            xScale = d3.scaleLinear()
                .domain([xExtent[0] - xRange * 0.1, xExtent[1] + xRange * 0.1])
                .range([0, width]);

            yScale = d3.scaleLinear()
                .domain([yExtent[0] - yRange * 0.1, yExtent[1] + yRange * 0.1])
                .range([height, 0]);

            // 2. Create Group Element
            const g = svg.append("g")
                .attr("transform", `translate(${margin.left}, ${margin.top})`);

            // 3. Add Axes
            g.append("g")
                .attr("transform", `translate(0, ${height})`)
                .call(d3.axisBottom(xScale));

            g.append("g")
                .call(d3.axisLeft(yScale));

            // 4. Draw Model Segments & Breakpoint Markers
            let breakpointXSet = new Set();
            if (trainedModel) {
                const segments = [];
                const keys = Array.from(trainedModel.keys()).filter(x => {
                    const segment = trainedModel.get(x);
                    return segment && !isNaN(segment[0]);
                }); 
                
                for (let i = 0; i < keys.length; i++) {
                    const x_start = keys[i];
                    const [P, O, x_end] = trainedModel.get(x_start);

                    // Collect breakpoints for later data point coloring
                    breakpointXSet.add(x_start);

                    if (!isNaN(P) && x_end) {
                        const y_start = P * x_start + O;
                        const y_end = P * x_end + O;
                        
                        // Collect endpoint
                        breakpointXSet.add(x_end);

                        segments.push({
                            x1: x_start,
                            y1: y_start,
                            x2: x_end,
                            y2: y_end
                        });
                    }
                }

                // Draw the segments
                g.selectAll(".model-segment")
                    .data(segments)
                    .enter().append("line")
                    .attr("class", "model-segment")
                    .attr("x1", d => xScale(d.x1))
                    .attr("y1", d => yScale(d.y1))
                    .attr("x2", d => xScale(d.x2))
                    .attr("y2", d => yScale(d.y2));

                // Draw breakpoint markers (small dark blue circles only on the segment ends)
                const breakpoints = Array.from(breakpointXSet).map(x => {
                    // Find the corresponding Y value from the original points
                    let y = originalPoints.find(p => p.x === x)?.y;
                    return {x, y};
                }).filter(p => p.y !== undefined);
                
                g.selectAll(".breakpoint")
                    .data(breakpoints)
                    .enter().append("circle")
                    .attr("class", "breakpoint")
                    .attr("cx", d => xScale(d.x))
                    .attr("cy", d => yScale(d.y))
                    .attr("r", 4);
            }

            // 5. Draw Original Data Points (Colored by status)
            g.selectAll(".original-point")
                .data(originalPoints)
                .enter().append("circle")
                .attr("class", d => breakpointXSet.has(d.x) ? "breakpoint-point" : "eliminated-point")
                .attr("cx", d => xScale(d.x))
                .attr("cy", d => yScale(d.y))
                .attr("r", 4);

            // 6. Add interaction area for prediction
            g.append("rect")
                .attr("class", "overlay")
                .attr("width", width)
                .attr("height", height)
                .style("fill", "none")
                .style("pointer-events", "all")
                .on("click", handlePredictionClick);
        }

        /**
         * Handles the click event on the chart for interactive prediction.
         */
        function handlePredictionClick(event) {
            if (!trainedModel || originalPoints.length === 0) {
                showPersistentMessage("El modelo no ha sido entrenado o los datos son insuficientes.");
                return;
            }

            const coords = d3.pointer(event);
            const x_in_pixel = coords[0];

            const x_in_model = xScale.invert(x_in_pixel);
            
            const result = predict_slrm(x_in_model, trainedModel);
            const y_pred = result.y_pred;

            const predBox = d3.select("#predictionBox").classed('hidden', false);
            d3.select("#predX").text(x_in_model.toFixed(3));
            // Display prediction with 6 decimal places for high precision
            d3.select("#predY").text(isNaN(y_pred) ? 'N/A (Error)' : y_pred.toFixed(6));
            
            const g = svg.select("g");
            g.selectAll(".prediction-line").remove();
            
            if (!isNaN(y_pred)) {
                // Draw prediction lines
                g.append("line")
                    .attr("class", "prediction-line")
                    .attr("x1", xScale(x_in_model))
                    .attr("y1", height)
                    .attr("x2", xScale(x_in_model))
                    .attr("y2", yScale(y_pred));
                
                g.append("line")
                    .attr("class", "prediction-line")
                    .attr("x1", 0)
                    .attr("y1", yScale(y_pred))
                    .attr("x2", xScale(x_in_model))
                    .attr("y2", yScale(y_pred));

                g.append("circle")
                    .attr("class", "prediction-line")
                    .attr("cx", xScale(x_in_model))
                    .attr("cy", yScale(y_pred))
                    .attr("r", 6)
                    .attr("fill", '#3b82f6');
            }
        }


        /**
         * Main function to handle training and UI updates.
         */
        document.getElementById('trainButton').addEventListener('click', async () => {
            const button = document.getElementById('trainButton');
            const spinner = document.getElementById('loadingSpinner');
            
            button.disabled = true;
            spinner.classList.remove('hidden');
            button.classList.add('opacity-70');

            await yieldControl(); // Initial yield to show spinner immediately

            try {
                const inputElement = document.getElementById('epsilon');
                const rawValue = inputElement.value.trim();
                let epsilon = parseFloat(rawValue);

                // Validation
                if (isNaN(epsilon) || epsilon < 0) {
                    showPersistentMessage("Por favor, introduce un valor de Epsilon válido y no negativo.");
                    return;
                }

                // SANITIZATION/NORMALIZATION: Force the input value to the exact parsed float value 
                // with high precision. This removes all redundant zeros (012 -> 12.000000, .5 -> 0.500000)
                // and fixes precision issues in the display.
                inputElement.value = epsilon.toFixed(6); 

                
                // TRAIN MODEL - Await the asynchronous training
                const trainResult = await train_slrm(document.getElementById('inputData').value, epsilon);
                trainedModel = trainResult.model;

                const originalCount = originalPoints.length;
                
                // Count the number of active segments
                const segmentCount = Array.from(trainedModel.keys()).filter(x => {
                    const segment = trainedModel.get(x);
                    return segment && !isNaN(segment[0]);
                }).length;

                // Update Metrics
                document.getElementById('metricPoints').textContent = originalCount;
                document.getElementById('metricSegments').textContent = segmentCount;
                // Display max error with 7 decimal places for high precision
                document.getElementById('metricMaxError').textContent = trainResult.maxError.toFixed(7);
                
                
                // Compression Ratio Calculation
                if (originalCount > 0) {
                    // Determine the unique set of X values that form the breakpoints of the final model
                    const finalBreakpointKeys = new Set();
                    for (const [x_start, segment] of trainedModel.entries()) {
                        const [P, O, x_end] = segment;
                        if (!isNaN(P)) {
                            finalBreakpointKeys.add(x_start);
                            if (x_end) finalBreakpointKeys.add(x_end);
                        }
                    }
                    const numBreakpoints = finalBreakpointKeys.size;

                    // Compression ratio = (Eliminated Points / Original Points) * 100
                    const eliminatedCount = originalCount - numBreakpoints;
                    const ratio = (eliminatedCount / originalCount) * 100;
                    document.getElementById('metricRatio').textContent = `${ratio.toFixed(2)}%`;
                } else {
                    document.getElementById('metricRatio').textContent = `0.00%`;
                }


                // Render the chart
                renderChart();

            } catch (error) {
                console.error("Training failed:", error);
                showPersistentMessage("Ocurrió un error durante el entrenamiento. Revisa el formato de los datos de entrada o el valor de Epsilon. Detalles del error en la consola.");
            } finally {
                button.disabled = false;
                spinner.classList.add('hidden');
                button.classList.remove('opacity-70');
            }
        });

        // Initialize on load and handle resize
        window.addEventListener('load', () => {
            document.getElementById('trainButton').click(); // Run initial training
            window.addEventListener('resize', renderChart);
        });

    </script>

</body>
</html>

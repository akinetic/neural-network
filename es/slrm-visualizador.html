<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Alex Kinetic and Logos">
    <title>SLRM-Logos Interactive Visualizer (V5.10b)</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- D3.js CDN for Visualization -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; }
        
        /* Point Coloring: Preferred D3 scheme (V5.8) */
        .eliminated-point { fill: #f87171; stroke: #ef4444; stroke-width: 1.5px; opacity: 0.8; } /* Red/Pink: Eliminated/intermediate points */
        .breakpoint-point { fill: #3b82f6; stroke: #1e3a8a; stroke-width: 1.5px; } /* Blue: Maintained/breakpoint points */

        .model-segment { stroke: #10b981; stroke-width: 3px; fill: none; }
        
        /* Prediction/Interactivity Styles */
        .prediction-line { stroke: #3b82f6; stroke-dasharray: 5, 5; stroke-width: 2px; }
        
        /* Responsive layout for Prediction input group - Custom for full width button */
        .prediction-input-container {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen p-4 sm:p-8">

    <div class="max-w-7xl mx-auto">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-gray-800">SLRM-Logos Visualizador Interactivo</h1>
            <!-- CHANGE: Removed font-semibold (bold) for cleaner look -->
            <p class="text-gray-600 mt-2">Modelo de Regresión Lineal Segmentada (MRLS con Invariancia Geométrica) <span class="text-gray-500">(Versión 5.10b)</span></p>
        </header>

        <!-- Configuration, Data, Metrics, and Prediction in a 4-column responsive grid -->
        <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
            
            <!-- 1. Data Input -->
            <div class="lg:col-span-2 bg-white p-6 rounded-xl shadow-lg border border-gray-200">
                <h2 class="text-xl font-semibold mb-3 text-gray-700">1. Datos de Entrada (X, Y)</h2>
                <textarea id="inputData" rows="10" class="w-full p-3 border border-gray-300 rounded-lg text-sm font-mono focus:ring-blue-500 focus:border-blue-500" placeholder="Ingrese puntos de datos (X, Y) separados por coma o espacio, uno por línea.">
1, 1
2, 1.5
3, 1.7
4, 3.5
5, 5
6, 4.8
7, 4.5
8, 4.3
9, 4.1
10, 4.2
11, 4.3
12, 4.6
13, 5.5
14, 7
15, 8.5
</textarea>
                <p class="text-xs text-gray-500 mt-1">Ejemplo: <code>X, Y</code> o <code>X Y</code></p>
            </div>

            <!-- 2. Model Configuration -->
            <div class="bg-white p-6 rounded-xl shadow-lg border border-gray-200">
                <h2 class="text-xl font-semibold mb-3 text-gray-700">2. Configuración</h2>
                <div class="mb-6">
                    <label for="epsilon" class="block text-sm font-medium text-gray-700 mb-1">Tolerancia de Error (Epsilon, &epsilon;)</label>
                    <!-- Default value set to 0.5 (simple) -->
                    <input type="text" id="epsilon" value="0.5" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 text-center font-mono">
                    <p class="text-xs text-gray-500 mt-1">Define la precisión del modelo.</p>
                </div>
                
                <button id="trainButton" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-[1.01] focus:outline-none focus:ring-4 focus:ring-blue-500/50">
                    <svg id="loadingSpinner" class="animate-spin -ml-1 mr-3 h-5 w-5 text-white hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                    Entrenar Modelo SLRM
                </button>
            </div>

            <!-- 3. Metrics -->
            <div class="bg-white p-6 rounded-xl shadow-lg border border-gray-200">
                <h2 class="text-xl font-semibold mb-3 text-gray-700">3. Métricas</h2>
                <div id="metrics-result" class="space-y-3 text-gray-700">
                    <p class="flex justify-between">
                        <span class="font-medium">Puntos Únicos:</span>
                        <span id="metricPoints" class="font-bold text-gray-800">0</span>
                    </p>
                    <p class="flex justify-between">
                        <span class="font-medium">Segmentos Finales:</span>
                        <span id="metricSegments" class="font-bold text-green-600">0</span>
                    </p>
                    <p class="flex justify-between">
                        <span class="font-medium">Relación de Compresión:</span>
                        <span id="metricRatio" class="font-bold text-blue-600">0.00%</span>
                    </p>
                    <p class="flex justify-between">
                        <span class="font-medium">Tiempo de Entrenamiento:</span>
                        <span id="metricTime" class="font-bold text-purple-600">N/A</span>
                    </p>
                    <p class="flex justify-between">
                        <span class="font-medium">Máx. Error Logrado:</span>
                        <!-- Max error is displayed with 6 decimal places for precision -->
                        <span id="metricMaxError" class="font-bold text-red-600">N/A</span>
                    </p>
                </div>
            </div>
            
            <!-- 4. Dedicated Prediction Test (New Section) -->
            <div class="sm:col-span-2 lg:col-span-1 bg-white p-6 rounded-xl shadow-lg border border-gray-200">
                <h2 class="text-xl font-semibold mb-4 text-gray-700">4. Test de Predicción</h2>
                <div class="prediction-input-container">
                    <div>
                        <label for="x-test-input" class="block text-sm font-medium text-gray-700 mb-1">Valor X a Predecir</label>
                        <!-- Default value set to 7.5 (simple) -->
                        <input type="text" id="x-test-input" value="7.5" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-green-500 focus:border-green-500 text-center font-mono">
                    </div>
                    <!-- Button is now full width and below the input -->
                    <button id="predictButton" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg transition duration-200 shadow-md">
                        Predecir
                    </button>
                </div>

                <div id="prediction-result" class="mt-4 p-3 text-sm rounded-lg text-gray-700">
                    <div class="flex flex-col space-y-3 text-left">
                        <!-- Prediction results are displayed with 6 decimal places -->
                        <span class="flex justify-between">
                            <span class="font-medium">Y (Predicción):</span> <span class="font-bold text-green-700">N/A</span>
                        </span>
                        <span class="flex justify-between">
                            <span class="font-medium">P (Pendiente):</span> <span class="font-bold">N/A</span>
                        </span>
                        <span class="flex justify-between">
                            <span class="font-medium">O (Ordenada):</span> <span class="font-bold">N/A</span>
                        </span>
                    </div>
                </div>
            </div>

        </div>

        <!-- Visualization Area -->
        <div class="bg-white p-4 sm:p-6 rounded-xl shadow-xl border border-gray-200">
            <h2 class="text-xl font-semibold mb-4 text-gray-700">Visualización del Modelo (Click en el gráfico para Predicción)</h2>
            <div id="chartContainer" class="w-full h-[500px] overflow-hidden">
                <svg id="slrmChart" class="w-full h-full"></svg>
            </div>
            <!-- Legend (Alineación vertical perfecta) -->
            <div class="p-3 mt-4 bg-gray-100 rounded-lg text-sm flex flex-wrap justify-around gap-4">
                <p class="flex items-center"><span class="inline-block w-3 h-3 bg-blue-500 rounded-full align-middle mr-1"></span> Puntos Críticos</p>
                <p class="flex items-center"><span class="inline-block w-3 h-3 bg-red-400 rounded-full align-middle mr-1"></span> Puntos Excluidos</p>
                <p class="flex items-center"><span class="inline-block w-4 h-0.5 bg-green-500 align-middle mr-1"></span> Segmentos SLRM</p>
                <p class="flex items-center"><span class="inline-block w-4 h-0.5 border-dashed border-red-500 align-middle mr-1 border"></span> Bandas de Error (&plusmn;&epsilon;)</p>
            </div>
        </div>
    </div>

    <script>
        // --- SLRM CORE LOGIC (V5.10b) ---

        // CONSTANTE DE PRECISIÓN PARA ARITMÉTICA DE PUNTO FLOTANTE
        const FLOAT_TOLERANCE = 1e-9; 
        let originalPoints = []; 
        let trainedModel = null;
        
        // Utilidad para ceder control al hilo principal (evita el congelamiento de la UI)
        const yieldControl = () => new Promise(resolve => setTimeout(resolve, 0));

        // --- DATA PROCESSING ---

        /**
         * Limpia y ordena los datos, manejando duplicados de X promediando Y.
         */
        function _cleanAndSortData(dataString) {
            const pointsMap = new Map();
            
            dataString.split('\n').forEach(line => {
                const parts = line.trim().split(/[\s,]+/).map(p => parseFloat(p.trim()));
                if (parts.length >= 2 && !isNaN(parts[0]) && !isNaN(parts[1])) {
                    const x = parts[0];
                    const y = parts[1];
                    
                    if (pointsMap.has(x)) {
                        const current = pointsMap.get(x);
                        current.y = (current.y * current.count + y) / (current.count + 1);
                        current.count += 1;
                    } else {
                        pointsMap.set(x, { x: x, y: y, count: 1 });
                    }
                }
            });

            const cleanedData = Array.from(pointsMap.values()).map(p => ({x: p.x, y: p.y}));
            cleanedData.sort((a, b) => a.x - b.x);

            return cleanedData;
        }

        // --- COMPRESSION LOGIC (Lossless: Invariancia Geométrica) ---

        /**
         * Realiza una compresión sin pérdidas (lossless) identificando puntos
         * no colineales (cambios de pendiente).
         */
        function _losslessCompression(data) {
            if (data.length < 2) return data.map(d => d.x);

            const criticalX = [data[0].x]; 
            
            for (let i = 1; i < data.length - 1; i++) {
                const p0 = data[i - 1]; 
                const p1 = data[i];     
                const p2 = data[i + 1]; 

                const dX_a = p1.x - p0.x;
                const dX_b = p2.x - p1.x;
                
                // Si dX es cero (o insignificante), incluimos el punto
                if (Math.abs(dX_a) < FLOAT_TOLERANCE || Math.abs(dX_b) < FLOAT_TOLERANCE) {
                    criticalX.push(p1.x); 
                    continue; 
                }

                const P_a = (p1.y - p0.y) / dX_a; 
                const P_b = (p2.y - p1.y) / dX_b; 

                // Verificación de colinealidad.
                if (Math.abs(P_a - P_b) > FLOAT_TOLERANCE) {
                    criticalX.push(p1.x);
                }
            }

            if (data.length > 1) {
                criticalX.push(data[data.length - 1].x);
            }

            return Array.from(new Set(criticalX));
        }

        // --- COMPRESSION LOGIC (Lossy / MRLS) ---
        
        /**
         * Calcula el error máximo de un segmento contra los puntos intermedios reales.
         */
        function _calculateSegmentMaxError(xS, xE, P, O, dataKeys, data) {
            if (isNaN(P)) return 0.0;
                
            const startIndex = dataKeys.indexOf(xS);
            const endIndex = dataKeys.indexOf(xE);
            let maxErr = 0.0;
            
            // Iterar SOLO sobre los puntos estrictamente intermedios
            for (let k = startIndex + 1; k < endIndex; k++) { 
                const xMid = data[k].x;
                const yTrueMid = data[k].y;
                
                const yHatMid = P * xMid + O;
                const error = Math.abs(yTrueMid - yHatMid);
                
                maxErr = Math.max(maxErr, error);
            }
            return maxErr;
        }


        /**
         * Aplica la compresión con pérdidas (Lossy) utilizando el algoritmo MRLS.
         */
        async function _lossyCompression(initialKeys, epsilon, data) {
            const dataKeys = data.map(d => d.x);
            const dataMap = new Map(data.map(p => [p.x, p.y]));
            
            if (initialKeys.length < 2) return { finalModel: new Map(), maxError: 0 };
            
            const finalModel = new Map();
            let i = 0; 
            let maxOverallError = 0;
            // Usar 1e-12 para epsilon=0
            const safeEpsilon = Math.max(epsilon, 1e-12); 

            // i: índice del punto de inicio (x_start) en initialKeys
            while (i < initialKeys.length - 1) {
                
                const x_start = initialKeys[i];
                const y_start = dataMap.get(x_start);
                
                let j = i + 1; // índice del punto de fin candidato (x_end_candidate) en initialKeys

                while (j < initialKeys.length) {
                    
                    // Ceder control al UI cada cierto tiempo
                    if ((j - (i + 1)) % 10 === 0) { await yieldControl(); } 

                    const x_end_candidate = initialKeys[j];
                    const y_end_candidate = dataMap.get(x_end_candidate);

                    const dX = x_end_candidate - x_start;
                    
                    // Si el cambio en X es cero (o insignificante) o NaN, salta al siguiente candidato.
                    if (isNaN(dX) || Math.abs(dX) < FLOAT_TOLERANCE) { 
                        j++; 
                        continue; 
                    } 

                    // Pendiente y Ordenada para el segmento candidato
                    const P_test = (y_end_candidate - y_start) / dX;
                    const O_test = y_start - P_test * x_start;

                    let errorExceeded = false;
                    
                    const startIndex = dataKeys.indexOf(x_start);
                    const endIndex = dataKeys.indexOf(x_end_candidate);

                    // Verificar todos los puntos *intermedios*
                    for (let k = startIndex + 1; k < endIndex; k++) {
                        const x_mid = data[k].x;
                        const y_true_mid = data[k].y;
                        
                        const y_hat_mid = P_test * x_mid + O_test;
                        const error = Math.abs(y_true_mid - y_hat_mid);

                        if (error > safeEpsilon) { 
                            errorExceeded = true;
                            break; 
                        }
                    }
                    
                    if (errorExceeded) {
                        // El segmento falló. La línea válida termina en el punto anterior (j-1).
                        const x_end_committed = initialKeys[j - 1];
                        const y_end_committed = dataMap.get(x_end_committed);
                        
                        const dX_committed = x_end_committed - x_start;
                        const P = dX_committed === 0 ? 0 : (y_end_committed - y_start) / dX_committed;
                        const O = y_start - P * x_start;
                        
                        // Guardar segmento: [Pendiente, Ordenada, X_Fin]
                        finalModel.set(x_start, [P, O, x_end_committed]);
                        
                        const committedMaxError = _calculateSegmentMaxError(x_start, x_end_committed, P, O, dataKeys, data);
                        maxOverallError = Math.max(maxOverallError, committedMaxError);

                        i = j - 1; // El siguiente segmento comienza donde terminó el anterior.
                        break; 
                        
                    } else if (j === initialKeys.length - 1) {
                        // Último punto alcanzado y pasó la prueba.
                        const x_end = initialKeys[j];
                        const y_end = dataMap.get(x_end);
                        
                        const dX = x_end - x_start;
                        const P = dX === 0 ? 0 : (y_end - y_start) / dX; 
                        const O = y_start - P * x_start;
                            
                        finalModel.set(x_start, [P, O, x_end]);
                        
                        const finalMaxError = _calculateSegmentMaxError(x_start, x_end, P, O, dataKeys, data);
                        maxOverallError = Math.max(maxOverallError, finalMaxError);
                        
                        i = j; // Termina el bucle externo
                        break;
                    }
                    
                    j++; // Intentar extender el segmento más
                }
            }

            // Marcador final para el último punto
            const lastKey = initialKeys[initialKeys.length - 1];
            if (lastKey !== undefined && !finalModel.has(lastKey)) {
                 // Usar [NaN, NaN, NaN] para puntos finales que no son inicios de segmento
                 finalModel.set(lastKey, [NaN, NaN, NaN]);
            }

            return { finalModel, maxError: maxOverallError };
        }


        // --- MAIN TRAINING AND PREDICTION ---

        /**
         * Función principal para entrenar el modelo SLRM.
         */
        async function train_slrm(dataString, epsilon) {
            originalPoints = _cleanAndSortData(dataString);
            if (originalPoints.length < 2) return { model: new Map(), originalData: originalPoints, maxError: 0 };
            
            const initialBreakpoints = _losslessCompression(originalPoints);
            
            await yieldControl();
            const result = await _lossyCompression(initialBreakpoints, epsilon, originalPoints);

            return { model: result.finalModel, originalData: originalPoints, maxError: result.maxError };
        }


        /**
         * Realiza una predicción Y para un valor X dado utilizando el modelo entrenado.
         */
        function predict_slrm(x_in, model) {
            const keys = Array.from(model.entries())
                // Filtrar solo las entradas que son inicios de segmento válidos (tienen Pendiente P)
                .filter(([x_start, [P]]) => !isNaN(P)) 
                .map(([x_start]) => x_start); 
            keys.sort((a, b) => a - b); 

            if (keys.length === 0 || originalPoints.length === 0) {
                return { x_in, y_pred: NaN, slope_P: NaN, intercept_O: NaN };
            }

            const dataMinX = originalPoints[0].x;
            const dataMaxX = originalPoints[originalPoints.length - 1].x;
            
            let activeKey = null;

            if (x_in < dataMinX) {
                // Extrapolation before data range: use the first segment
                activeKey = keys[0];
            } else if (x_in >= dataMaxX) {
                // Extrapolation after data range: use the last segment
                activeKey = keys[keys.length - 1]; 
            } else {
                // Interpolation: find the segment where x_in falls
                for (let i = 0; i < keys.length; i++) {
                    const x_start = keys[i];
                    const x_end = model.get(x_start)[2]; // x_end is the 3rd element in the segment array
                    
                    // Check if x_in is in [x_start, x_end)
                    if (x_in >= x_start && x_in < x_end) { 
                        activeKey = x_start;
                        break;
                    }
                }
                // Fallback for the last segment if x_in is exactly the last breakpoint (x_max)
                if (activeKey === null) {
                    activeKey = keys[keys.length - 1];
                }
            }
            
            if (activeKey === undefined) {
                 return { x_in, y_pred: NaN, slope_P: NaN, intercept_O: NaN };
            }

            // [P, O, x_end]
            const [P, O] = model.get(activeKey) || [NaN, NaN];
            
            let y_pred = NaN;
            if (!isNaN(P) && !isNaN(O)) {
                y_pred = x_in * P + O;
            }

            return {
                x_in,
                y_pred,
                slope_P: P,
                intercept_O: O
            };
        }

        // --- D3 VISUALIZATION AND INTERACTIVITY ---

        const svg = d3.select("#slrmChart");
        const margin = { top: 20, right: 30, bottom: 40, left: 50 };
        let width, height;
        let xScale, yScale;

        function updateDimensions() {
            width = svg.node().clientWidth - margin.left - margin.right;
            height = svg.node().clientHeight - margin.top - margin.bottom;
        }

        /**
         * Renders the chart using D3.js.
         */
        function renderChart(epsilon) {
            updateDimensions();
            svg.selectAll("*").remove(); // Clear previous chart content

            if (originalPoints.length < 2 || !trainedModel) {
                svg.append("text")
                   .attr("x", width / 2 + margin.left)
                   .attr("y", height / 2 + margin.top)
                   .attr("text-anchor", "middle")
                   .attr("fill", "#94a3b8")
                   .style("font-size", "20px")
                   .text("Entrene el modelo para visualizar los datos.");
                return;
            }

            // 1. Define Scales
            const xExtent = d3.extent(originalPoints, d => d.x);
            const yExtent = d3.extent(originalPoints, d => d.y);

            const xRange = xExtent[1] - xExtent[0];
            const yRange = yExtent[1] - yExtent[0];

            // Use a margin of 10% of the range on both sides
            const xMargin = xRange * 0.1;
            const yMargin = yRange * 0.1;

            xScale = d3.scaleLinear()
                .domain([xExtent[0] - xMargin, xExtent[1] + xMargin])
                .range([0, width]);

            yScale = d3.scaleLinear()
                // Must account for epsilon in the Y domain for band visibility
                .domain([yExtent[0] - yMargin - epsilon, yExtent[1] + yMargin + epsilon]) 
                .range([height, 0]);

            // 2. Create Group Element
            const g = svg.append("g")
                .attr("transform", `translate(${margin.left}, ${margin.top})`);

            // 3. Add Axes
            g.append("g")
                .attr("transform", `translate(0, ${height})`)
                .call(d3.axisBottom(xScale));

            g.append("g")
                .call(d3.axisLeft(yScale));

            // 4. Draw Error Bands (if epsilon > 0)
            if (epsilon > 1e-6) {
                const area = d3.area()
                    .x(d => xScale(d.x))
                    .y0(d => yScale(d.y - epsilon))
                    .y1(d => yScale(d.y + epsilon))
                    .curve(d3.curveLinear); 

                g.append("path")
                    .datum(originalPoints)
                    .attr("fill", "rgba(252, 165, 165, 0.2)") 
                    .attr("stroke", "#f87171") 
                    .attr("stroke-width", 1)
                    .attr("d", area);
            }


            // 5. Draw Model Segments & Breakpoint Markers
            let breakpointXSet = new Set();
            const segments = [];
            
            const keys = Array.from(trainedModel.keys()).filter(x => {
                const segment = trainedModel.get(x);
                return segment && !isNaN(segment[0]);
            }); 
            
            for (let i = 0; i < keys.length; i++) {
                const x_start = keys[i];
                // Segment data: [P, O, x_end]
                const [P, O, x_end] = trainedModel.get(x_start); 

                breakpointXSet.add(x_start);

                if (!isNaN(P) && x_end) {
                    const y_start = P * x_start + O;
                    const y_end = P * x_end + O;
                    
                    breakpointXSet.add(x_end);

                    segments.push({
                        x1: x_start,
                        y1: y_start,
                        x2: x_end,
                        y2: y_end
                    });
                }
            }

            // Draw the segments
            g.selectAll(".model-segment")
                .data(segments)
                .enter().append("line")
                .attr("class", "model-segment")
                .attr("x1", d => xScale(d.x1))
                .attr("y1", d => yScale(d.y1))
                .attr("x2", d => xScale(d.x2))
                .attr("y2", d => yScale(d.y2));

            // Draw Original Data Points (Colored by status)
            g.selectAll(".original-point")
                .data(originalPoints)
                .enter().append("circle")
                .attr("class", d => breakpointXSet.has(d.x) ? "breakpoint-point" : "eliminated-point")
                .attr("cx", d => xScale(d.x))
                .attr("cy", d => yScale(d.y))
                .attr("r", 4);


            // Draw breakpoint markers (small dark blue circles only on the segment ends)
            const breakpoints = Array.from(breakpointXSet).map(x => {
                // Find the original Y value for the breakpoint X
                let y = originalPoints.find(p => Math.abs(p.x - x) < FLOAT_TOLERANCE)?.y;
                return {x, y};
            }).filter(p => p.y !== undefined);
            
            g.selectAll(".breakpoint")
                .data(breakpoints)
                .enter().append("circle")
                .attr("class", "breakpoint")
                .attr("cx", d => xScale(d.x))
                .attr("cy", d => yScale(d.y))
                .attr("r", 4.5)
                .attr("fill", "transparent")
                .attr("stroke", "#1e3a8a")
                .attr("stroke-width", 2);

            // 6. Add interaction area for prediction
            g.append("rect")
                .attr("class", "overlay")
                .attr("width", width)
                .attr("height", height)
                .style("fill", "none")
                .style("pointer-events", "all")
                .on("click", (event) => handlePredictionClick(event, true)); 
        }

        /**
         * Maneja la predicción desde el botón o el click en el gráfico.
         */
        function updatePrediction(x_in, isChartClick) {
            // Check if model is ready or input is valid
            if (!trainedModel || originalPoints.length === 0 || isNaN(x_in)) {
                // If input is NaN and not a chart click, do nothing (keep previous results).
                if (!isChartClick && isNaN(x_in)) {
                    return; 
                }
            }

            const result = predict_slrm(x_in, trainedModel);
            const y_pred = result.y_pred;

            let isPredictionVisible = false;

            // CRITICAL: Only draw prediction if it is visible within the D3 scales/domain.
            if (xScale && yScale) {
                const [minX, maxX] = xScale.domain();
                const [minY, maxY] = yScale.domain();

                // Check if the prediction point falls within the current visual domain
                if (x_in >= minX && x_in <= maxX && y_pred >= minY && y_pred <= maxY) {
                    isPredictionVisible = true;
                }
            } 
            
            // Output values (Y, P, O) are consistently displayed with 6 decimal places.
            const predText = isNaN(y_pred) ? 'N/A' : y_pred.toFixed(6); 
            const P_text = isNaN(result.slope_P) ? 'N/A' : result.slope_P.toFixed(6); 
            const O_text = isNaN(result.intercept_O) ? 'N/A' : result.intercept_O.toFixed(6); 
            
            // If it was a chart click, update the input box with the X value, limited to 6 decimals
            if (isChartClick) {
                // Limit the X input update to 6 decimals for cleaner display
                document.getElementById('x-test-input').value = x_in.toFixed(6); 
            }
            
            // Update the prediction results display (Section 4)
            document.getElementById('prediction-result').innerHTML = `
                <div class="flex flex-col space-y-3 text-left">
                    <span class="flex justify-between">
                        <span class="font-medium">Y (Predicción):</span> <span class="font-bold text-green-700">${predText}</span>
                    </span>
                    <span class="flex justify-between">
                        <span class="font-medium">P (Pendiente):</span> <span class="font-bold">${P_text}</span>
                    </span>
                    <span class="flex justify-between">
                        <span class="font-medium">O (Ordenada):</span> <span class="font-bold">${O_text}</span>
                    </span>
                </div>
            `;
            
            // Draw prediction lines only if prediction is a number AND VISIBLE on the chart
            const g = svg.select("g");
            g.selectAll(".prediction-line").remove();
            
            if (!isNaN(y_pred) && isPredictionVisible) {
                // Check if scales exist before drawing
                if (xScale && yScale) {
                    g.append("line")
                        .attr("class", "prediction-line")
                        .attr("x1", xScale(x_in))
                        .attr("y1", height)
                        .attr("x2", xScale(x_in))
                        .attr("y2", yScale(y_pred));
                    
                    g.append("line")
                        .attr("class", "prediction-line")
                        .attr("x1", 0)
                        .attr("y1", yScale(y_pred))
                        .attr("x2", xScale(x_in))
                        .attr("y2", yScale(y_pred));

                    g.append("circle")
                        .attr("class", "prediction-line")
                        .attr("cx", xScale(x_in))
                        .attr("cy", yScale(y_pred))
                        .attr("r", 6)
                        .attr("fill", '#3b82f6');
                }
            }
        }

        function handlePredictionClick(event) {
            const coords = d3.pointer(event);
            const x_in_pixel = coords[0];
            const x_in_model = xScale.invert(x_in_pixel);
            updatePrediction(x_in_model, true);
        }

        document.getElementById('predictButton').addEventListener('click', () => {
            const xTestInput = document.getElementById('x-test-input').value;
            const xTest = parseFloat(xTestInput); 

            if (isNaN(xTest)) {
                // If input is NaN, the updatePrediction will handle the N/A output.
                return;
            }
            updatePrediction(xTest, false);
        });


        // --- MAIN HANDLER ---

        document.getElementById('trainButton').addEventListener('click', async () => {
            const button = document.getElementById('trainButton');
            const spinner = document.getElementById('loadingSpinner');
            
            // Bloquear UI
            button.disabled = true;
            spinner.classList.remove('hidden');
            button.classList.add('opacity-70');

            await yieldControl();

            try {
                const inputElement = document.getElementById('epsilon');
                const rawValue = inputElement.value.trim();
                let epsilon = parseFloat(rawValue);

                if (isNaN(epsilon) || epsilon < 0) {
                    console.error("Error: Epsilon must be a valid non-negative number.");
                    return; 
                }
                
                const dataString = document.getElementById('inputData').value;
                
                // Start timer
                const startTime = performance.now(); 
                
                const trainResult = await train_slrm(dataString, epsilon);
                
                // Stop timer and calculate elapsed time
                const endTime = performance.now(); 
                const elapsedTime = (endTime - startTime) / 1000; // Time in seconds
                
                trainedModel = trainResult.model;

                const originalCount = originalPoints.length; // Puntos únicos y limpios
                
                // Contar segmentos válidos
                const segmentCount = Array.from(trainedModel.keys()).filter(x => {
                    const segment = trainedModel.get(x);
                    return segment && !isNaN(segment[0]);
                }).length;

                // Update Metrics
                document.getElementById('metricPoints').textContent = originalCount; 
                document.getElementById('metricSegments').textContent = segmentCount;
                // Max Error is displayed with 6 decimal places.
                document.getElementById('metricMaxError').textContent = trainResult.maxError.toFixed(6); 
                document.getElementById('metricTime').textContent = `${elapsedTime.toFixed(4)} s`; // Update Training Time
                
                
                if (originalCount > 0) {
                    // Contar los breakpoints finales para la relación de compresión
                    const finalBreakpointKeys = new Set();
                    for (const [x_start, segment] of trainedModel.entries()) {
                        const [P, O, x_end] = segment;
                        // Añadir x_start si es un segmento válido
                        if (!isNaN(P)) {
                            finalBreakpointKeys.add(x_start);
                        }
                        // Añadir x_end si existe y es válido
                        if (x_end && !isNaN(x_end)) {
                            // Buscar el punto final en los puntos originales para asegurar su existencia
                            const exists = originalPoints.some(p => Math.abs(p.x - x_end) < FLOAT_TOLERANCE);
                            if (exists) {
                                finalBreakpointKeys.add(x_end);
                            }
                        }
                    }
                    const numBreakpoints = finalBreakpointKeys.size;
                    
                    const eliminatedCount = originalCount - numBreakpoints;
                    const ratio = (originalCount > 0) ? (eliminatedCount / originalCount) * 100 : 0;
                    document.getElementById('metricRatio').textContent = `${ratio.toFixed(2)}%`;

                    // Predicción inicial
                    const xTest = parseFloat(document.getElementById('x-test-input').value);
                    if (!isNaN(xTest)) {
                        updatePrediction(xTest, false);
                    }
                } else {
                    // Reset prediction result structure
                    document.getElementById('prediction-result').innerHTML = `
                        <div class="flex flex-col space-y-3 text-left">
                            <span class="font-medium">Y (Predicción):</span> <span class="font-bold text-green-700">N/A</span>
                            <span class="font-medium">P (Pendiente):</span> <span class="font-bold">N/A</span>
                            <span class="font-medium">O (Ordenada):</span> <span class="font-bold">N/A</span>
                        </div>
                    `;
                    document.getElementById('metricRatio').textContent = `0.00%`;
                }

                // Render the chart
                renderChart(epsilon);

            } catch (error) {
                console.error("Training failed:", error);
                // For simplicity and non-blocking nature, only log errors.
            } finally {
                // Desbloquear UI
                button.disabled = false;
                spinner.classList.add('hidden');
                button.classList.remove('opacity-70');
            }
        });

        // Initial setup on load
        window.addEventListener('load', () => {
            document.getElementById('trainButton').click(); 
            window.addEventListener('resize', () => {
                // Parse the value from the text input
                const epsilon = parseFloat(document.getElementById('epsilon').value || 0);
                renderChart(epsilon);
                // Parse the value from the text input
                const xTest = parseFloat(document.getElementById('x-test-input').value); 
                if (!isNaN(xTest)) {
                    updatePrediction(xTest, false);
                }
            });
        });

    </script>
</body>
</html>

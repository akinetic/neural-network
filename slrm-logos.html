<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- CHANGE: Version number fixed at V5.6 -->
    <title>SLRM-Logos Interactive Visualizer (V5.6)</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- D3.js CDN for Visualization -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; }
        .data-point { fill: #f87171; stroke: #b91c1c; stroke-width: 1.5px; }
        .model-segment { stroke: #10b981; stroke-width: 3px; fill: none; }
        .breakpoint { fill: #1e3a8a; stroke: #1e3a8a; stroke-width: 2px; }
        .prediction-line { stroke: #3b82f6; stroke-dasharray: 5, 5; stroke-width: 2px; }
        /* Style for custom alert/message box */
        .message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 15px 30px;
            background-color: #fefcbf; /* Yellow warning background */
            border: 2px solid #facc15;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            max-width: 90%;
            text-align: center;
            opacity: 1;
            transition: opacity 0.5s ease;
        }
        .message-box.hidden {
            display: none;
            opacity: 0;
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen p-4 sm:p-8">

    <div class="max-w-7xl mx-auto">
        <header class="text-center mb-8">
            <!-- CHANGE: Version number fixed at V5.6 -->
            <h1 class="text-4xl font-bold text-gray-800">SLRM-Logos Interactive Visualizer <span class="text-sm font-light text-gray-500">(V5.6)</span></h1>
            <p class="text-gray-600 mt-2">Segmented Linear Regression Model (MRLS Algorithm)</p>
        </header>

        <!-- Configuration and Metrics -->
        <div class="grid grid-cols-1 lg:col-cols-3 gap-6 mb-8">
            <!-- Data Input -->
            <div class="col-span-1 lg:col-span-1 bg-white p-6 rounded-xl shadow-lg border border-gray-200">
                <h2 class="text-xl font-semibold mb-3 text-gray-700">1. Input Data (X, Y)</h2>
                <textarea id="inputData" rows="10" class="w-full p-3 border border-gray-300 rounded-lg text-sm font-mono focus:ring-blue-500 focus:border-blue-500" placeholder="Enter data points (X, Y) separated by comma or space, one per line.">
1, 1
2, 1.5
3, 1.7
4, 3.5
5, 5
6, 4.8
7, 4.5
8, 4.3
9, 4.1
10, 4.2
11, 4.3
12, 4.6
13, 5.5
14, 7
15, 8.5
</textarea>
                <p class="text-xs text-gray-500 mt-1">Example: <code>X, Y</code> or <code>X Y</code></p>
            </div>

            <!-- Controls and Parameters -->
            <div class="col-span-1 lg:col-span-1 bg-white p-6 rounded-xl shadow-lg border border-gray-200">
                <h2 class="text-xl font-semibold mb-3 text-gray-700">2. Configuration</h2>
                <div class="mb-4">
                    <label for="epsilon" class="block text-sm font-medium text-gray-700 mb-1">Error Tolerance (Epsilon, &epsilon;)</label>
                    <!-- CHANGE: Step adjusted for the new, extreme precision -->
                    <input type="number" id="epsilon" value="0.5" step="0.000001" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500">
                    <p class="text-xs text-gray-500 mt-1">Lower &epsilon; = More Segments (Higher Fidelity)</p>
                </div>
                
                <button id="trainButton" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-[1.01] focus:outline-none focus:ring-4 focus:ring-blue-500/50">
                    <svg id="loadingSpinner" class="animate-spin -ml-1 mr-3 h-5 w-5 text-white hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                    Train SLRM Model
                </button>
            </div>

            <!-- Metrics -->
            <div class="col-span-1 lg:col-span-1 bg-white p-6 rounded-xl shadow-lg border border-gray-200">
                <h2 class="text-xl font-semibold mb-3 text-gray-700">3. Model Metrics</h2>
                <div class="space-y-3 text-gray-700">
                    <p class="flex justify-between">
                        <span class="font-medium">Original Points:</span>
                        <span id="metricPoints" class="font-bold text-gray-800">0</span>
                    </p>
                    <p class="flex justify-between">
                        <span class="font-medium">Segments (Breakpoints):</span>
                        <span id="metricSegments" class="font-bold text-green-600">0</span>
                    </p>
                    <p class="flex justify-between">
                        <span class="font-medium">Compression Ratio:</span>
                        <span id="metricRatio" class="font-bold text-blue-600">0.00%</span>
                    </p>
                    <p class="flex justify-between">
                        <span class="font-medium">Max Error Achieved:</span>
                        <span id="metricMaxError" class="font-bold text-red-600">N/A</span>
                    </p>
                </div>
                <div id="predictionBox" class="mt-4 p-3 bg-indigo-50 border border-indigo-200 rounded-lg hidden">
                    <p class="text-sm font-semibold text-indigo-800">Click Prediction (X= <span id="predX"></span>)</p>
                    <p class="text-lg font-bold text-indigo-900">Ŷ = <span id="predY"></span></p>
                </div>
            </div>
        </div>

        <!-- Visualization Area -->
        <div class="bg-white p-4 sm:p-6 rounded-xl shadow-xl border border-gray-200">
            <h2 class="text-xl font-semibold mb-4 text-gray-700">4. Model Visualization (Click on chart for Prediction)</h2>
            <div id="chartContainer" class="w-full h-[500px] overflow-hidden">
                <svg id="slrmChart" class="w-full h-full"></svg>
            </div>
        </div>
    </div>

    <!-- Custom Message Box for errors/warnings -->
    <div id="customMessageBox" class="message-box hidden">
        <p id="messageText" class="text-lg font-semibold text-gray-900 mb-0"></p>
        <!-- The close button is removed for timed messages, but kept for persistent errors -->
    </div>

    <script>
        // --- UTILITY FUNCTIONS ---
        
        /**
         * Shows a persistent error message (requires user click to close).
         */
        function showPersistentMessage(text) {
            const msgBox = document.getElementById('customMessageBox');
            document.getElementById('messageText').textContent = text;
            msgBox.classList.remove('hidden');
            // Change background for error
            msgBox.style.backgroundColor = '#fee2e2'; 
            msgBox.style.borderColor = '#ef4444';
            // Add a close button for persistent messages
            let closeBtn = msgBox.querySelector('button');
            if (!closeBtn) {
                closeBtn = document.createElement('button');
                closeBtn.textContent = 'Cerrar';
                closeBtn.onclick = () => msgBox.classList.add('hidden');
                closeBtn.className = 'bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg mt-3';
                msgBox.appendChild(closeBtn);
            }
        }
        
        /**
         * Shows a temporary warning message that disappears after 3 seconds.
         */
        function showTimedMessage(text) {
            const msgBox = document.getElementById('customMessageBox');
            document.getElementById('messageText').textContent = text;
            msgBox.classList.remove('hidden');
            
            // Remove close button if present
            let closeBtn = msgBox.querySelector('button');
            if (closeBtn) {
                msgBox.removeChild(closeBtn);
            }

            // Restore warning styles
            msgBox.style.backgroundColor = '#fefcbf';
            msgBox.style.borderColor = '#facc15';

            // Automatically hide after 3 seconds
            setTimeout(() => {
                msgBox.classList.add('hidden');
            }, 3000); 
        }

        // Utility function to yield control back to the UI thread (prevents freezing)
        const yieldControl = () => new Promise(resolve => setTimeout(resolve, 0));

        // --- SLRM CORE LOGIC ---

        /** Global variable to store original points for boundary checks */
        let originalPoints = []; 

        /**
         * Cleans and sorts input data, handling duplicate X values by averaging Y.
         */
        function _cleanAndSortData(dataString) {
            const pointsMap = new Map();
            const rawLines = dataString.split('\n');
            
            rawLines.forEach(line => {
                const parts = line.trim().split(/[\s,]+/).map(p => parseFloat(p.trim()));
                if (parts.length >= 2 && !isNaN(parts[0]) && !isNaN(parts[1])) {
                    const x = parts[0];
                    const y = parts[1];
                    
                    if (pointsMap.has(x)) {
                        const current = pointsMap.get(x);
                        current.y = (current.y * current.count + y) / (current.count + 1);
                        current.count += 1;
                    } else {
                        pointsMap.set(x, { x: x, y: y, count: 1 });
                    }
                }
            });

            const cleanedData = Array.from(pointsMap.values()).map(p => ({x: p.x, y: p.y}));
            cleanedData.sort((a, b) => a.x - b.x);

            return cleanedData;
        }

        /**
         * Calculates Slope (P) and Intercept (O) for every adjacent segment.
         */
        function _calculateOptimizedDict(data) {
            const model = new Map();
            for (let i = 0; i < data.length - 1; i++) {
                const p1 = data[i];
                const p2 = data[i+1];
                
                if (p2.x - p1.x === 0) continue; 
                
                const P = (p2.y - p1.y) / (p2.x - p1.x); // Slope
                const O = p1.y - P * p1.x; // Intercept

                model.set(p1.x, [P, O, p2.x]); // [P, O, X_end]
            }
            if (data.length > 0) {
                model.set(data[data.length - 1].x, [NaN, NaN, NaN]);
            }
            return model;
        }

        /**
         * Removes geometrically collinear breakpoints (Lossless Compression).
         */
        function _losslessCompression(model) {
            const keys = Array.from(model.keys());
            const newModel = new Map();

            for (let i = 0; i < keys.length - 1; i++) {
                const x_start = keys[i];
                const x_mid = keys[i+1];
                
                const [P_start] = model.get(x_start);
                const [P_mid] = model.get(x_mid) || [NaN]; 

                if (i === keys.length - 2) {
                    newModel.set(x_start, model.get(x_start));
                    break;
                }

                if (Math.abs(P_start - P_mid) < 1e-9) {
                    // Collinear: skip x_mid.
                } else {
                    // Non-collinear: x_start is a critical breakpoint.
                    newModel.set(x_start, model.get(x_start));
                }
            }

            const dataMap = new Map(originalPoints.map(p => [p.x, p.y]));
            const finalKeys = Array.from(newModel.keys()).filter(x => !isNaN(x)); 
            
            for (let i = 0; i < finalKeys.length; i++) {
                const x_start = finalKeys[i];
                let x_end = finalKeys[i+1];
                if (i === finalKeys.length - 1) {
                    x_end = keys[keys.length - 1]; // The very last X coordinate
                }

                const y_start = dataMap.get(x_start);
                const y_end = dataMap.get(x_end);

                if (y_start !== undefined && y_end !== undefined && x_end !== x_start) {
                    const denominator = x_end - x_start;
                    if (denominator === 0) continue; 
                    
                    const P = (y_end - y_start) / denominator;
                    const O = y_start - P * x_start;
                    newModel.set(x_start, [P, O, x_end]);
                }
            }
            
            const allKeys = Array.from(model.keys());
            if (allKeys.length > 0) {
                 newModel.set(allKeys[allKeys.length - 1], [NaN, NaN, NaN]);
            }

            return newModel;
        }

        /**
         * Implements the Minimum Required Line Segments (MRLS) algorithm (Lossy Compression).
         */
        async function _lossyCompression(model, epsilon, data) {
            const dataKeys = data.map(d => d.x);
            const dataMap = new Map(data.map(p => [p.x, p.y]));
            const initialKeys = Array.from(model.keys()).filter(x => !isNaN(x)); 
            
            if (initialKeys.length < 2) {
                return { finalModel: model, maxError: 0 };
            }

            // Fallback for extreme precision stability
            const safeEpsilon = Math.max(epsilon, 1e-12); 

            const finalModel = new Map();
            let i = 0; // Index of the starting breakpoint in initialKeys
            let maxOverallError = 0;

            // MRLS Loop: Attempts to extend the segment starting at initialKeys[i] as far as possible
            while (i < initialKeys.length - 1) {
                
                const x_start = initialKeys[i];
                const y_start = dataMap.get(x_start);
                
                let j = i + 1; // Index of the candidate ending breakpoint (x_end_candidate)

                while (j < initialKeys.length) {
                    
                    if ((j - (i + 1)) % 5 === 0) { 
                        await yieldControl();
                    }

                    const x_end_candidate = initialKeys[j];
                    const y_end_candidate = dataMap.get(x_end_candidate);

                    // P and O calculation for the TEST segment (i -> j)
                    const P_test = (y_end_candidate - y_start) / (x_end_candidate - x_start);
                    const O_test = y_start - P_test * x_start;

                    let maxSegmentError = 0;
                    let errorExceeded = false;
                    
                    // Check all original points between x_start and x_end_candidate
                    const startIndex = dataKeys.indexOf(x_start);
                    const endIndex = dataKeys.indexOf(x_end_candidate);

                    for (let k = startIndex + 1; k < endIndex; k++) {
                        const x_mid = data[k].x;
                        const y_true_mid = data[k].y;
                        
                        const y_hat_mid = P_test * x_mid + O_test;
                        const error = Math.abs(y_true_mid - y_hat_mid);

                        maxSegmentError = Math.max(maxSegmentError, error);

                        if (error > safeEpsilon) { 
                            errorExceeded = true;
                            break; 
                        }
                    }
                    
                    if (errorExceeded) {
                        // Max segment found: it ends at the previous breakpoint (j-1).
                        
                        let x_end;
                        let new_i;

                        if (j === i + 1) {
                            // CORRECCIÓN DE CONTINUIDAD: The shortest segment (i -> i+1) failed.
                            // We force this segment to ensure continuity.
                            x_end = initialKeys[j];
                            new_i = j; // Next segment starts at j = i+1
                            
                        } else {
                            // Segment i -> (j-1) is the longest valid segment.
                            x_end = initialKeys[j - 1];
                            new_i = j - 1; // Next segment starts at j-1
                        }
                        
                        const y_end = dataMap.get(x_end);
                        
                        // Recalculate P and O for the final segment (x_start to x_end)
                        const P = (y_end - y_start) / (x_end - x_start);
                        const O = y_start - P * x_start;
                        
                        finalModel.set(x_start, [P, O, x_end]);
                        maxOverallError = Math.max(maxOverallError, maxSegmentError); // Update max error
                        
                        i = new_i; // Move the start index
                        break; // Exit the inner 'j' loop
                        
                    } else if (j === initialKeys.length - 1) {
                        // Reached the very last point, this is the final segment (i -> j).
                        const x_end = initialKeys[j];
                        const y_end = dataMap.get(x_end);
                        
                        const P = (y_end - y_start) / (x_end - x_start);
                        const O = y_start - P * x_start;
                        
                        finalModel.set(x_start, [P, O, x_end]);
                        maxOverallError = Math.max(maxOverallError, maxSegmentError);
                        
                        i = j; // Loop terminates
                        break;
                    }
                    
                    j++; // Try to extend the segment further
                }
            }

            // Re-add the final NaN marker
            const allKeys = Array.from(model.keys());
            if (allKeys.length > 0) {
                 finalModel.set(allKeys[allKeys.length - 1], [NaN, NaN, NaN]);
            }

            return { finalModel, maxError: maxOverallError };
        }


        /**
         * Main training function (mimics slrm-logos.py:train_slrm). Made ASYNC.
         */
        async function train_slrm(dataString, epsilon) {
            originalPoints = _cleanAndSortData(dataString);
            if (originalPoints.length < 2) return { model: new Map(), originalData: originalPoints, maxError: 0 };
            
            // 1. Base Model (Optimization)
            let model = _calculateOptimizedDict(originalPoints);
            
            // 2. Lossless Compression
            model = _losslessCompression(model);

            // 3. Lossy Compression (MRLS) - Await the asynchronous function
            await yieldControl();
            const result = await _lossyCompression(model, epsilon, originalPoints);

            return { model: result.finalModel, originalData: originalPoints, maxError: result.maxError };
        }

        /**
         * Main prediction function (mimics slrm-logos.py:predict_slrm).
         */
        function predict_slrm(x_in, model) {
            const keys = Array.from(model.entries())
                .filter(([x_start, [P]]) => !isNaN(P))
                .map(([x_start]) => x_start); 
            keys.sort((a, b) => a - b); 

            if (keys.length === 0 || originalPoints.length === 0) {
                return { x_in, y_pred: NaN, slope_P: NaN, intercept_O: NaN };
            }

            const dataMinX = originalPoints[0].x;
            const dataMaxX = originalPoints[originalPoints.length - 1].x;
            
            let activeKey = null;

            if (x_in < dataMinX) {
                // Left Extrapolation: Use the first segment
                activeKey = keys[0];
            } else if (x_in >= dataMaxX) {
                // Right Extrapolation: Use the parameters of the last *active* segment.
                activeKey = keys[keys.length - 1]; 
            } else {
                 // Interpolation 
                for (let i = 0; i < keys.length; i++) {
                    if (keys[i] <= x_in) {
                        activeKey = keys[i];
                    } else {
                        break;
                    }
                }
                if (activeKey === null) activeKey = keys[0];
            }

            const [P, O] = model.get(activeKey) || [NaN, NaN];
            
            let y_pred = NaN;
            if (!isNaN(P) && !isNaN(O)) {
                y_pred = x_in * P + O;
            }

            return {
                x_in,
                y_pred,
                slope_P: P,
                intercept_O: O
            };
        }


        // --- D3 VISUALIZATION AND INTERACTIVITY ---

        const svg = d3.select("#slrmChart");
        const margin = { top: 20, right: 30, bottom: 40, left: 50 };
        let width, height;
        let xScale, yScale;
        let trainedModel = null;
        let modelKeys = [];

        function updateDimensions() {
            width = svg.node().clientWidth - margin.left - margin.right;
            height = svg.node().clientHeight - margin.top - margin.bottom;
        }

        /**
         * Renders the chart using D3.js.
         */
        function renderChart() {
            updateDimensions();
            svg.selectAll("*").remove(); // Clear previous chart content

            if (originalPoints.length === 0) return;

            // 1. Define Scales
            const xExtent = d3.extent(originalPoints, d => d.x);
            const yExtent = d3.extent(originalPoints, d => d.y);

            const xRange = xExtent[1] - xExtent[0];
            const yRange = yExtent[1] - yExtent[0];

            xScale = d3.scaleLinear()
                .domain([xExtent[0] - xRange * 0.1, xExtent[1] + xRange * 0.1])
                .range([0, width]);

            yScale = d3.scaleLinear()
                .domain([yExtent[0] - yRange * 0.1, yExtent[1] + yRange * 0.1])
                .range([height, 0]);

            // 2. Create Group Element
            const g = svg.append("g")
                .attr("transform", `translate(${margin.left}, ${margin.top})`);

            // 3. Add Axes
            g.append("g")
                .attr("transform", `translate(0, ${height})`)
                .call(d3.axisBottom(xScale));

            g.append("g")
                .call(d3.axisLeft(yScale));

            // 4. Draw Model Segments
            if (trainedModel) {
                const segments = [];
                const keys = Array.from(trainedModel.keys()).filter(x => !isNaN(trainedModel.get(x)[0])); 
                
                for (let i = 0; i < keys.length; i++) {
                    const x_start = keys[i];
                    const [P, O, x_end] = trainedModel.get(x_start);

                    if (!isNaN(P) && x_end) {
                        const y_start = P * x_start + O;
                        const y_end = P * x_end + O;

                        segments.push({
                            x1: x_start,
                            y1: y_start,
                            x2: x_end,
                            y2: y_end
                        });
                    }
                }

                // Draw the segments
                g.selectAll(".model-segment")
                    .data(segments)
                    .enter().append("line")
                    .attr("class", "model-segment")
                    .attr("x1", d => xScale(d.x1))
                    .attr("y1", d => yScale(d.y1))
                    .attr("x2", d => xScale(d.x2))
                    .attr("y2", d => yScale(d.y2));

                // Draw breakpoints
                const breakpoints = segments.map(s => ({x: s.x1, y: s.y1}));
                if (segments.length > 0) {
                    breakpoints.push({x: segments[segments.length - 1].x2, y: segments[segments.length - 1].y2});
                }
                
                g.selectAll(".breakpoint")
                    .data(breakpoints)
                    .enter().append("circle")
                    .attr("class", "breakpoint")
                    .attr("cx", d => xScale(d.x))
                    .attr("cy", d => yScale(d.y))
                    .attr("r", 4);
            }

            // 5. Draw Original Data Points
            g.selectAll(".data-point")
                .data(originalPoints)
                .enter().append("circle")
                .attr("class", "data-point")
                .attr("cx", d => xScale(d.x))
                .attr("cy", d => yScale(d.y))
                .attr("r", 4);

            // 6. Add interaction area for prediction
            g.append("rect")
                .attr("class", "overlay")
                .attr("width", width)
                .attr("height", height)
                .style("fill", "none")
                .style("pointer-events", "all")
                .on("click", handlePredictionClick);
        }

        /**
         * Handles the click event on the chart for interactive prediction.
         */
        function handlePredictionClick(event) {
            if (!trainedModel || originalPoints.length === 0) {
                showPersistentMessage("El modelo no ha sido entrenado o los datos son insuficientes.");
                return;
            }

            const coords = d3.pointer(event);
            const x_in_pixel = coords[0];

            const x_in_model = xScale.invert(x_in_pixel);
            
            const result = predict_slrm(x_in_model, trainedModel);
            const y_pred = result.y_pred;

            const predBox = d3.select("#predictionBox").classed('hidden', false);
            d3.select("#predX").text(x_in_model.toFixed(3));
            // Display prediction with 6 decimal places for high precision
            d3.select("#predY").text(isNaN(y_pred) ? 'N/A (Error)' : y_pred.toFixed(6));
            
            const g = svg.select("g");
            g.selectAll(".prediction-line").remove();
            
            if (!isNaN(y_pred)) {
                // Draw prediction lines
                g.append("line")
                    .attr("class", "prediction-line")
                    .attr("x1", xScale(x_in_model))
                    .attr("y1", height)
                    .attr("x2", xScale(x_in_model))
                    .attr("y2", yScale(y_pred));
                
                g.append("line")
                    .attr("class", "prediction-line")
                    .attr("x1", 0)
                    .attr("y1", yScale(y_pred))
                    .attr("x2", xScale(x_in_model))
                    .attr("y2", yScale(y_pred));

                g.append("circle")
                    .attr("class", "prediction-line")
                    .attr("cx", xScale(x_in_model))
                    .attr("cy", yScale(y_pred))
                    .attr("r", 6)
                    .attr("fill", '#3b82f6');
            }
        }


        /**
         * Main function to handle training and UI updates.
         */
        document.getElementById('trainButton').addEventListener('click', async () => {
            const button = document.getElementById('trainButton');
            const spinner = document.getElementById('loadingSpinner');
            
            button.disabled = true;
            spinner.classList.remove('hidden');
            button.classList.add('opacity-70');

            await yieldControl(); // Initial yield to show spinner immediately

            try {
                const dataString = document.getElementById('inputData').value;
                let epsilon = parseFloat(document.getElementById('epsilon').value);
                
                // CHANGE: Minimum Epsilon set to 0.000001 for maximum rigor
                const MIN_PRACTICAL_EPSILON = 0.000001; 

                if (isNaN(epsilon) || epsilon <= 0) {
                    showPersistentMessage("Please enter a positive and valid Epsilon value.");
                    return;
                }

                if (epsilon < MIN_PRACTICAL_EPSILON) {
                    const warningText = `Minimum Epsilon Enforced: ${MIN_PRACTICAL_EPSILON}`;
                    showTimedMessage(warningText);
                    document.getElementById('epsilon').value = MIN_PRACTICAL_EPSILON;
                    epsilon = MIN_PRACTICAL_EPSILON;
                }

                // TRAIN MODEL - Await the asynchronous training
                const trainResult = await train_slrm(dataString, epsilon);
                trainedModel = trainResult.model;

                const originalCount = originalPoints.length;
                
                const segmentCount = Array.from(trainedModel.keys()).filter(x => !isNaN(trainedModel.get(x)[0])).length;
                

                // Update Metrics
                document.getElementById('metricPoints').textContent = originalCount;
                document.getElementById('metricSegments').textContent = segmentCount;
                // Display max error with 7 decimal places to reflect the new rigor
                document.getElementById('metricMaxError').textContent = trainResult.maxError.toFixed(7);
                
                if (originalCount > 0) {
                    const ratio = ((originalCount - segmentCount) / originalCount) * 100;
                    document.getElementById('metricRatio').textContent = `${ratio.toFixed(2)}%`;
                } else {
                    document.getElementById('metricRatio').textContent = `0.00%`;
                }

                // Render the chart
                renderChart();

            } catch (error) {
                console.error("Training failed:", error);
                showPersistentMessage("An error occurred during training. Check input data format or Epsilon value. Error details in console.");
            } finally {
                button.disabled = false;
                spinner.classList.add('hidden');
                button.classList.remove('opacity-70');
            }
        });

        // Initialize on load and handle resize
        window.addEventListener('load', () => {
            document.getElementById('trainButton').click(); // Run initial training
            window.addEventListener('resize', renderChart);
        });

        // Expose data globally for debugging/inspection (optional)
        window.trainedModel = null;
    </script>

</body>
</html>
